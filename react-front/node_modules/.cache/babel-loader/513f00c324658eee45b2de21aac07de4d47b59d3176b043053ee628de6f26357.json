{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\n\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-1.5-flash-latest\"; // Using a standard model ID\nconst OUTPUT_SAMPLE_RATE = 24000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // State for the Live session and audio\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // --- AUDIO QUEUE IMPLEMENTATION ---\n  // Refs are used to hold the queue and playback state to avoid issues with stale state in callbacks.\n  const audioQueue = useRef([]);\n  const isPlaybackActive = useRef(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) {\n      avatarRef.current.play();\n    } else {\n      avatarRef.current.stop();\n    }\n  }, [isSpeaking]);\n\n  // ---------- Audio Conversion Helpers (Unchanged) ----------\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- Queued Playback Logic ----------\n\n  const processQueue = useCallback(() => {\n    // If the queue is empty or playback is already active, do nothing.\n    if (audioQueue.current.length === 0 || isPlaybackActive.current) {\n      return;\n    }\n\n    // Mark playback as active and set the speaking animation\n    isPlaybackActive.current = true;\n    setIsSpeaking(true);\n\n    // Get the next audio chunk from the front of the queue\n    const int16le = audioQueue.current.shift();\n\n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n\n    // **CRUCIAL CHANGE**: The onended event handles the queue.\n    src.onended = () => {\n      // Mark playback as inactive\n      isPlaybackActive.current = false;\n      // If the queue is now empty, stop the speaking animation\n      if (audioQueue.current.length === 0) {\n        setIsSpeaking(false);\n      }\n      // **Process the next item in the queue**\n      processQueue();\n    };\n    src.start();\n  }, [audioCtx]); // Dependency on audioCtx\n\n  // ---------- Live Session Start / Stop ----------\n\n  const startLive = async () => {\n    // Reset state before starting a new session\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n\n    // 1) Ask server for ephemeral token (Unchanged)\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n    const ephemeralKey = typeof token === \"string\" ? token : token === null || token === void 0 ? void 0 : token.name;\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      }\n    });\n\n    // 2) Connect to the live session\n    const s = await ai.getGenerativeModel({\n      model: MODEL\n    }).connect();\n    setSession(s);\n\n    // Set up the callbacks\n    s.onmessage = msg => {\n      var _msg$speechUpdate;\n      const base64Audio = (msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) || (msg === null || msg === void 0 ? void 0 : msg.data) || null;\n      if (typeof base64Audio === \"string\") {\n        // **CHANGE**: Add to queue instead of playing directly\n        audioQueue.current.push(base64ToInt16(base64Audio));\n        processQueue();\n      } else if (base64Audio instanceof ArrayBuffer) {\n        audioQueue.current.push(new Int16Array(base64Audio));\n        processQueue();\n      }\n    };\n    s.onerror = e => console.error(\"Live error:\", e);\n    s.onclose = () => console.log(\"Live session closed\");\n\n    // 3) Open the mic (Unchanged)\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model (Unchanged)\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1);\n    src.connect(proc);\n    proc.connect(ctx.destination);\n    proc.onaudioprocess = e => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const mime = \"audio/pcm;rate=16000\";\n      s.sendRealtimeInput({\n        audio: {\n          data: arrayBufferToBase64(pcm16.buffer),\n          mimeType: mime\n        }\n      });\n    };\n  };\n  const stopLive = async () => {\n    // Clear the queue on stop\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Send a text turn (Unchanged)\n  const sendText = async text => {\n    if (!session) return;\n    session.sendClientContent({\n      text,\n      turnComplete: true\n    });\n  };\n\n  // --- Render method (Unchanged) ---\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Talking AI Avatar (Gemini Live)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginTop: 12\n      },\n      children: !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startLive,\n        children: \"Start Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => sendText(\"नमस्ते! आप कैसे हैं?\"),\n          children: \"Send Text Turn\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: stopLive,\n          children: \"Stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 230,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        opacity: 0.7,\n        marginTop: 8\n      },\n      children: session ? isSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and give mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 213,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"UF0lyyAQQ4fEChi4O0MdAIJJSO8=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","App","_s","avatarRef","session","setSession","audioCtx","setAudioCtx","micStream","setMicStream","isSpeaking","setIsSpeaking","audioQueue","isPlaybackActive","current","play","stop","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","outRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","String","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","processQueue","int16le","shift","ctx","window","AudioContext","webkitAudioContext","sampleRate","f32","createBuffer","copyToChannel","src","createBufferSource","connect","destination","onended","start","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","getGenerativeModel","model","onmessage","msg","_msg$speechUpdate","base64Audio","speechUpdate","audio","data","push","ArrayBuffer","onerror","e","console","error","onclose","log","stream","navigator","mediaDevices","getUserMedia","createMediaStreamSource","proc","createScriptProcessor","onaudioprocess","inBuf","inputBuffer","getChannelData","ds","pcm16","mime","sendRealtimeInput","mimeType","stopLive","getTracks","forEach","t","_session$close","close","call","sendText","text","sendClientContent","turnComplete","className","children","fileName","_jsxFileName","lineNumber","columnNumber","lottieRef","animationData","loop","autoplay","style","height","display","gap","marginTop","onClick","opacity","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\n\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL = \"gemini-1.5-flash-latest\"; // Using a standard model ID\nconst OUTPUT_SAMPLE_RATE = 24000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // State for the Live session and audio\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // --- AUDIO QUEUE IMPLEMENTATION ---\n  // Refs are used to hold the queue and playback state to avoid issues with stale state in callbacks.\n  const audioQueue = useRef([]);\n  const isPlaybackActive = useRef(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) {\n      avatarRef.current.play();\n    } else {\n      avatarRef.current.stop();\n    }\n  }, [isSpeaking]);\n\n  // ---------- Audio Conversion Helpers (Unchanged) ----------\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n  \n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- Queued Playback Logic ----------\n\n  const processQueue = useCallback(() => {\n    // If the queue is empty or playback is already active, do nothing.\n    if (audioQueue.current.length === 0 || isPlaybackActive.current) {\n      return;\n    }\n\n    // Mark playback as active and set the speaking animation\n    isPlaybackActive.current = true;\n    setIsSpeaking(true);\n\n    // Get the next audio chunk from the front of the queue\n    const int16le = audioQueue.current.shift();\n\n    // Lazily create an AudioContext at 24k\n    const ctx =\n      audioCtx ||\n      new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: OUTPUT_SAMPLE_RATE,\n      });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n    \n    // **CRUCIAL CHANGE**: The onended event handles the queue.\n    src.onended = () => {\n      // Mark playback as inactive\n      isPlaybackActive.current = false;\n      // If the queue is now empty, stop the speaking animation\n      if (audioQueue.current.length === 0) {\n        setIsSpeaking(false);\n      }\n      // **Process the next item in the queue**\n      processQueue();\n    };\n\n    src.start();\n  }, [audioCtx]); // Dependency on audioCtx\n\n  // ---------- Live Session Start / Stop ----------\n\n  const startLive = async () => {\n    // Reset state before starting a new session\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n    \n    // 1) Ask server for ephemeral token (Unchanged)\n    const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(\n      (r) => r.json()\n    );\n    const ephemeralKey = typeof token === \"string\" ? token : token?.name;\n\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: { apiVersion: \"v1alpha\" },\n    });\n\n    // 2) Connect to the live session\n    const s = await ai.getGenerativeModel({ model: MODEL }).connect();\n    setSession(s);\n    \n    // Set up the callbacks\n    s.onmessage = (msg) => {\n        const base64Audio = msg?.speechUpdate?.audio || msg?.data || null;\n        if (typeof base64Audio === \"string\") {\n            // **CHANGE**: Add to queue instead of playing directly\n            audioQueue.current.push(base64ToInt16(base64Audio));\n            processQueue();\n        } else if (base64Audio instanceof ArrayBuffer) {\n            audioQueue.current.push(new Int16Array(base64Audio));\n            processQueue();\n        }\n    };\n    s.onerror = (e) => console.error(\"Live error:\", e);\n    s.onclose = () => console.log(\"Live session closed\");\n\n\n    // 3) Open the mic (Unchanged)\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model (Unchanged)\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1);\n    src.connect(proc);\n    proc.connect(ctx.destination);\n    proc.onaudioprocess = (e) => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const mime = \"audio/pcm;rate=16000\";\n      s.sendRealtimeInput({\n        audio: { data: arrayBufferToBase64(pcm16.buffer), mimeType: mime },\n      });\n    };\n  };\n\n  const stopLive = async () => {\n    // Clear the queue on stop\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        await session.close?.();\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Send a text turn (Unchanged)\n  const sendText = async (text) => {\n    if (!session) return;\n    session.sendClientContent({ text, turnComplete: true });\n  };\n  \n  // --- Render method (Unchanged) ---\n  return (\n    <div className=\"app\">\n      <h2>Talking AI Avatar (Gemini Live)</h2>\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n      <div style={{ display: \"flex\", gap: 8, marginTop: 12 }}>\n        {!session ? (\n          <button onClick={startLive}>Start Live</button>\n        ) : (\n          <>\n            <button onClick={() => sendText(\"नमस्ते! आप कैसे हैं?\")}>\n              Send Text Turn\n            </button>\n            <button onClick={stopLive}>Stop</button>\n          </>\n        )}\n      </div>\n      <p style={{ opacity: 0.7, marginTop: 8 }}>\n        {session\n          ? isSpeaking\n            ? \"Model is speaking...\"\n            : \"Live connected. Speak into your mic.\"\n          : \"Click Start Live and give mic permission.\"}\n      </p>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}