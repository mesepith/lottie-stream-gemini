{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-2.5-flash-live-preview\";\nconst OUTPUT_SAMPLE_RATE = 24000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n  const audioQueue = useRef({\n    queue: [],\n    nextPlayTime: 0,\n    isPlaying: false\n  });\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isModelSpeaking, setIsModelSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isModelSpeaking) {\n      avatarRef.current.play();\n    } else {\n      avatarRef.current.stop();\n    }\n  }, [isModelSpeaking]);\n\n  // ---------- helpers: audio conversions ----------\n  // (These functions are correct and remain unchanged)\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- NEW: Playback for streaming audio ----------\n\n  const processAudioQueue = () => {\n    if (audioQueue.current.isPlaying || audioQueue.current.queue.length === 0) {\n      return;\n    }\n\n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!audioCtx) setAudioCtx(ctx);\n    audioQueue.current.isPlaying = true;\n    setIsModelSpeaking(true);\n    const int16le = audioQueue.current.queue.shift();\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n\n    // This is the key: schedule the start time\n    const currentTime = ctx.currentTime;\n    const startTime = Math.max(currentTime, audioQueue.current.nextPlayTime);\n    src.start(startTime);\n\n    // Update the time for the next chunk\n    audioQueue.current.nextPlayTime = startTime + buffer.duration;\n    src.onended = () => {\n      audioQueue.current.isPlaying = false;\n      if (audioQueue.current.queue.length > 0) {\n        processAudioQueue(); // Process next chunk if available\n      } else {\n        setIsModelSpeaking(false); // No more chunks, model has stopped\n      }\n    };\n  };\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    // Reset the audio queue on start\n    audioQueue.current = {\n      queue: [],\n      nextPlayTime: 0,\n      isPlaying: false\n    };\n\n    // 1) Ask server for ephemeral token\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n    const ephemeralKey = typeof token === \"string\" ? token : token === null || token === void 0 ? void 0 : token.name;\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      }\n    });\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: {\n            prebuiltVoiceConfig: {\n              voiceName: \"Kore\"\n            }\n          }\n        }\n      },\n      callbacks: {\n        onmessage: msg => {\n          var _msg$speechUpdate;\n          const base64Audio = (msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) || (msg === null || msg === void 0 ? void 0 : msg.data) || null;\n          if (typeof base64Audio === \"string\") {\n            // Instead of playing, add to queue and process\n            audioQueue.current.queue.push(base64ToInt16(base64Audio));\n            processAudioQueue();\n          } else if (base64Audio instanceof ArrayBuffer) {\n            audioQueue.current.queue.push(new Int16Array(base64Audio));\n            processAudioQueue();\n          }\n        },\n        onerror: e => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\")\n      }\n    });\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model\n    const micAudioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = micAudioCtx.createMediaStreamSource(stream);\n    const proc = micAudioCtx.createScriptProcessor(4096, 1, 1);\n    src.connect(proc);\n    proc.connect(micAudioCtx.destination);\n    proc.onaudioprocess = e => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      const ds = downsampleTo16k(inBuf, micAudioCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const mime = \"audio/pcm;rate=16000\";\n      s.sendRealtimeInput({\n        audio: {\n          data: arrayBufferToBase64(pcm16.buffer),\n          mimeType: mime\n        }\n      });\n    };\n  };\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    // Reset state\n    setIsModelSpeaking(false);\n    audioQueue.current = {\n      queue: [],\n      nextPlayTime: 0,\n      isPlaying: false\n    };\n  };\n\n  // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async text => {\n    if (!session) return;\n    session.sendClientContent({\n      text,\n      turnComplete: true\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 216,\n      columnNumber: 7\n    }, this), !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startLive,\n      children: \"Start Live\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => sendText(\"नमस्ते! आप कैसे हैं?\"),\n        children: \"Send Text Turn\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 227,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: stopLive,\n        children: \"Stop\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 230,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: session ? isModelSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and give mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 215,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"fO1LQlTBCmw22tjaNjtBCBlggQo=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","App","_s","avatarRef","audioQueue","queue","nextPlayTime","isPlaying","session","setSession","audioCtx","setAudioCtx","micStream","setMicStream","isModelSpeaking","setIsModelSpeaking","current","play","stop","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","outRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","String","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","processAudioQueue","ctx","window","AudioContext","webkitAudioContext","sampleRate","int16le","shift","f32","createBuffer","copyToChannel","src","createBufferSource","connect","destination","currentTime","startTime","start","duration","onended","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onmessage","msg","_msg$speechUpdate","base64Audio","speechUpdate","audio","data","push","ArrayBuffer","onerror","e","console","error","onclose","log","stream","navigator","mediaDevices","getUserMedia","micAudioCtx","createMediaStreamSource","proc","createScriptProcessor","onaudioprocess","inBuf","inputBuffer","getChannelData","ds","pcm16","mime","sendRealtimeInput","mimeType","stopLive","getTracks","forEach","t","_session$close","close","call","sendText","text","sendClientContent","turnComplete","children","lottieRef","animationData","loop","autoplay","style","height","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL = \"gemini-2.5-flash-live-preview\";\nconst OUTPUT_SAMPLE_RATE = 24000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n  const audioQueue = useRef({ queue: [], nextPlayTime: 0, isPlaying: false });\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isModelSpeaking, setIsModelSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isModelSpeaking) {\n      avatarRef.current.play();\n    } else {\n      avatarRef.current.stop();\n    }\n  }, [isModelSpeaking]);\n\n\n  // ---------- helpers: audio conversions ----------\n  // (These functions are correct and remain unchanged)\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- NEW: Playback for streaming audio ----------\n  \n  const processAudioQueue = () => {\n    if (audioQueue.current.isPlaying || audioQueue.current.queue.length === 0) {\n      return;\n    }\n    \n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: OUTPUT_SAMPLE_RATE,\n    });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    audioQueue.current.isPlaying = true;\n    setIsModelSpeaking(true);\n\n    const int16le = audioQueue.current.queue.shift();\n    \n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n        f32[i] = int16le[i] / 0x8000;\n    }\n\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n\n    // This is the key: schedule the start time\n    const currentTime = ctx.currentTime;\n    const startTime = Math.max(currentTime, audioQueue.current.nextPlayTime);\n    src.start(startTime);\n    \n    // Update the time for the next chunk\n    audioQueue.current.nextPlayTime = startTime + buffer.duration;\n    \n    src.onended = () => {\n        audioQueue.current.isPlaying = false;\n        if (audioQueue.current.queue.length > 0) {\n            processAudioQueue(); // Process next chunk if available\n        } else {\n            setIsModelSpeaking(false); // No more chunks, model has stopped\n        }\n    };\n  };\n\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    // Reset the audio queue on start\n    audioQueue.current = { queue: [], nextPlayTime: 0, isPlaying: false };\n\n    // 1) Ask server for ephemeral token\n    const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(\n      (r) => r.json()\n    );\n    const ephemeralKey = typeof token === \"string\" ? token : token?.name;\n\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: { apiVersion: \"v1alpha\" },\n    });\n\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Kore\" } },\n        },\n      },\n      callbacks: {\n        onmessage: (msg) => {\n          const base64Audio = msg?.speechUpdate?.audio || msg?.data || null;\n          if (typeof base64Audio === \"string\") {\n            // Instead of playing, add to queue and process\n            audioQueue.current.queue.push(base64ToInt16(base64Audio));\n            processAudioQueue();\n          } else if (base64Audio instanceof ArrayBuffer) {\n            audioQueue.current.queue.push(new Int16Array(base64Audio));\n            processAudioQueue();\n          }\n        },\n        onerror: (e) => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\"),\n      },\n    });\n\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model\n    const micAudioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = micAudioCtx.createMediaStreamSource(stream);\n    const proc = micAudioCtx.createScriptProcessor(4096, 1, 1);\n    src.connect(proc);\n    proc.connect(micAudioCtx.destination);\n    proc.onaudioprocess = (e) => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      const ds = downsampleTo16k(inBuf, micAudioCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const mime = \"audio/pcm;rate=16000\";\n      s.sendRealtimeInput({\n        audio: { data: arrayBufferToBase64(pcm16.buffer), mimeType: mime },\n      });\n    };\n  };\n\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        await session.close?.();\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    // Reset state\n    setIsModelSpeaking(false);\n    audioQueue.current = { queue: [], nextPlayTime: 0, isPlaying: false };\n  };\n  \n    // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async (text) => {\n    if (!session) return;\n    session.sendClientContent({\n      text,\n      turnComplete: true,\n    });\n  };\n\n  return (\n    <div>\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n      {!session ? (\n        <button onClick={startLive}>Start Live</button>\n      ) : (\n        <>\n          <button onClick={() => sendText(\"नमस्ते! आप कैसे हैं?\")}>\n            Send Text Turn\n          </button>\n          <button onClick={stopLive}>Stop</button>\n        </>\n      )}\n      <p>\n        {session\n          ? isModelSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\"\n          : \"Click Start Live and give mic permission.\"}\n      </p>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}