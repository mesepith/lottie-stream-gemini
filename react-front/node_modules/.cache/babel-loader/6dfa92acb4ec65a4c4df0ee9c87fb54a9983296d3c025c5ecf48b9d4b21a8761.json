{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\n// ✅ Correct Live model id\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-live-2.5-flash-preview\";\n\n// Live output is 24 kHz PCM (model → you)\nconst OUTPUT_SAMPLE_RATE = 24000;\n// We’ll stream mic to model at 16 kHz PCM (you → model)\nconst INPUT_SAMPLE_RATE = 16000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // --- session & audio state ---\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Separate contexts: input (recording), output (playback @24k)\n  const inputCtxRef = useRef(null);\n  const outputCtxRef = useRef(null);\n\n  // Playback queue (sequential, no overlaps)\n  const playQueueRef = useRef([]);\n  const drainingRef = useRef(false);\n\n  // Simple VAD-ish flag for logging user “voice” once per burst\n  const voiceActiveRef = useRef(false);\n\n  // Conversation log: [{time, role:'user'|'ai'|'system', text}]\n  const [log, setLog] = useState([]);\n\n  // Drive avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers ----------\n\n  function nowHHMMSS() {\n    const d = new Date();\n    const pad = n => String(n).padStart(2, \"0\");\n    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n  }\n  function addLog(role, text) {\n    setLog(prev => [...prev, {\n      time: nowHHMMSS(),\n      role,\n      text\n    }]);\n  }\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample Float32 (device rate) → 16 kHz\n  function downsampleTo16k(float32, inRate) {\n    if (inRate === INPUT_SAMPLE_RATE) return float32;\n    const ratio = inRate / INPUT_SAMPLE_RATE;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: strict FIFO @ 24 kHz (no overlaps) ----------\n\n  async function enqueuePlayback(chunk) {\n    // chunk may be base64 (most common) or ArrayBuffer (older SDKs)\n    let int16;\n    if (typeof chunk === \"string\") int16 = base64ToInt16(chunk);else if (chunk instanceof ArrayBuffer) int16 = new Int16Array(chunk);else return;\n    playQueueRef.current.push(int16);\n    if (!drainingRef.current) drainPlayback();\n  }\n  async function drainPlayback() {\n    drainingRef.current = true;\n\n    // lazy output context (fixed @24k for clean pitch)\n    const out = outputCtxRef.current || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!outputCtxRef.current) outputCtxRef.current = out;\n    while (playQueueRef.current.length) {\n      const int16 = playQueueRef.current.shift();\n\n      // Int16 → Float32\n      const f32 = new Float32Array(int16.length);\n      for (let i = 0; i < int16.length; i++) f32[i] = int16[i] / 0x8000;\n\n      // Buffer @ 24 kHz\n      const buf = out.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n      buf.copyToChannel(f32, 0);\n      await new Promise(resolve => {\n        const src = out.createBufferSource();\n        src.buffer = buf;\n        src.connect(out.destination);\n        setIsSpeaking(true);\n        src.start();\n        src.onended = () => {\n          setIsSpeaking(false);\n          resolve();\n        };\n      });\n    }\n    drainingRef.current = false;\n  }\n\n  // Try to extract any text the SDK provides for AI turns\n  function extractMessageText(msg) {\n    var _sc$modelTurn;\n    // Common fields seen in preview SDKs:\n    if (typeof (msg === null || msg === void 0 ? void 0 : msg.text) === \"string\" && msg.text.trim()) return msg.text.trim();\n\n    // Some variants attach text in serverContent / modelTurn / parts\n    const sc = msg === null || msg === void 0 ? void 0 : msg.serverContent;\n    if (sc !== null && sc !== void 0 && sc.output && Array.isArray(sc.output)) {\n      const t = sc.output.map(o => o === null || o === void 0 ? void 0 : o.text).filter(Boolean).join(\" \").trim();\n      if (t) return t;\n    }\n    if (sc !== null && sc !== void 0 && (_sc$modelTurn = sc.modelTurn) !== null && _sc$modelTurn !== void 0 && _sc$modelTurn.parts) {\n      const t = sc.modelTurn.parts.map(p => typeof (p === null || p === void 0 ? void 0 : p.text) === \"string\" ? p.text : \"\").join(\" \").trim();\n      if (t) return t;\n    }\n\n    // Candidates-style (older shapes)\n    if (Array.isArray(msg === null || msg === void 0 ? void 0 : msg.candidates)) {\n      for (const c of msg.candidates) {\n        var _c$content, _c$content$parts;\n        const t = c === null || c === void 0 ? void 0 : (_c$content = c.content) === null || _c$content === void 0 ? void 0 : (_c$content$parts = _c$content.parts) === null || _c$content$parts === void 0 ? void 0 : _c$content$parts.map(p => typeof (p === null || p === void 0 ? void 0 : p.text) === \"string\" ? p.text : \"\").join(\" \").trim();\n        if (t) return t;\n      }\n    }\n    return null;\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    if (session) return; // already running\n\n    // 1) fetch ephemeral token from your Node server (v1alpha required)\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n    const ephemeralKey = typeof token === \"string\" ? token : token === null || token === void 0 ? void 0 : token.name;\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      } // REQUIRED for ephemeral tokens\n    });\n\n    // 2) connect the Live session\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\", \"TEXT\"],\n        // get audio + text for logging\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: {\n            prebuiltVoiceConfig: {\n              voiceName: \"Puck\"\n            }\n          }\n        }\n      },\n      callbacks: {\n        onopen: () => {\n          addLog(\"system\", \"Live connected\");\n        },\n        onmessage: msg => {\n          var _msg$speechUpdate$aud, _msg$speechUpdate, _msg$serverContent;\n          // Play audio (if any) sequentially\n          const audio = (_msg$speechUpdate$aud = msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) !== null && _msg$speechUpdate$aud !== void 0 ? _msg$speechUpdate$aud : msg === null || msg === void 0 ? void 0 : msg.data;\n          if (audio) enqueuePlayback(audio);\n\n          // Log AI text if provided\n          const text = extractMessageText(msg);\n          if (text) addLog(\"ai\", text);\n\n          // Mark end-of-turn to stop avatar if no more audio buffers come\n          if (msg !== null && msg !== void 0 && (_msg$serverContent = msg.serverContent) !== null && _msg$serverContent !== void 0 && _msg$serverContent.turnComplete) {\n            // let onended of the last buffer stop the avatar\n          }\n        },\n        onerror: e => {\n          console.error(\"Live error:\", e);\n          addLog(\"system\", `Error: ${String((e === null || e === void 0 ? void 0 : e.message) || e)}`);\n        },\n        onclose: () => {\n          addLog(\"system\", \"Live session closed\");\n        }\n      }\n    });\n    setSession(s);\n\n    // 3) open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) capture mic frames and stream to the model\n    const inCtx = new (window.AudioContext || window.webkitAudioContext)();\n    inputCtxRef.current = inCtx;\n    const src = inCtx.createMediaStreamSource(stream);\n    const proc = inCtx.createScriptProcessor(4096, 1, 1);\n\n    // Keep node alive but DO NOT route mic to speakers (avoid echo/“double voice”)\n    const nullOut = inCtx.createGain();\n    nullOut.gain.value = 0;\n    src.connect(proc);\n    proc.connect(nullOut);\n    nullOut.connect(inCtx.destination);\n    proc.onaudioprocess = e => {\n      const ch = e.inputBuffer.getChannelData(0);\n\n      // naive VAD for logging a \"voice\" marker once per burst\n      const rms = ch.reduce((acc, v) => acc + Math.abs(v), 0) / Math.max(1, ch.length);\n      const talking = rms > 0.02; // tweak threshold as needed\n      if (talking && !voiceActiveRef.current) {\n        voiceActiveRef.current = true;\n        addLog(\"user\", \"[voice]\");\n      } else if (!talking && voiceActiveRef.current) {\n        voiceActiveRef.current = false;\n      }\n\n      // downsample & encode to PCM16 @16k\n      const ds = downsampleTo16k(ch, inCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const b64 = arrayBufferToBase64(pcm16.buffer);\n\n      // Stream chunk to Live (correct API for JS)\n      s.sendRealtimeInput({\n        audio: {\n          data: b64,\n          mimeType: `audio/pcm;rate=${INPUT_SAMPLE_RATE}`\n        }\n      });\n    };\n  };\n  const stopLive = async () => {\n    // stop mic tracks\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    // close input context\n    if (inputCtxRef.current) {\n      try {\n        await inputCtxRef.current.close();\n      } catch {}\n      inputCtxRef.current = null;\n    }\n    // clear playback queue & close output context\n    playQueueRef.current = [];\n    drainingRef.current = false;\n    if (outputCtxRef.current) {\n      try {\n        await outputCtxRef.current.close();\n      } catch {}\n      outputCtxRef.current = null;\n    }\n    // close session\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    setIsSpeaking(false);\n    voiceActiveRef.current = false;\n    addLog(\"system\", \"Stopped\");\n  };\n\n  // Optional: send a text turn while mic is streaming\n  const sendText = async text => {\n    if (!session || !(text !== null && text !== void 0 && text.trim())) return;\n    addLog(\"user\", text.trim());\n    session.sendClientContent({\n      text: text.trim(),\n      turnComplete: true // tell model to respond now\n    });\n  };\n\n  // Simple input for text messages\n  const [textInput, setTextInput] = useState(\"\");\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    style: {\n      maxWidth: 720,\n      margin: \"24px auto\",\n      padding: 16\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Talking AI Avatar (Gemini Live)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 326,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 328,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginTop: 12\n      },\n      children: !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startLive,\n        children: \"Start Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          style: {\n            flex: 1,\n            padding: 8\n          },\n          placeholder: \"Type a message\\u2026\",\n          value: textInput,\n          onChange: e => setTextInput(e.target.value),\n          onKeyDown: e => {\n            if (e.key === \"Enter\") {\n              sendText(textInput);\n              setTextInput(\"\");\n            }\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 341,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            sendText(textInput);\n            setTextInput(\"\");\n          },\n          children: \"Send\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 353,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: stopLive,\n          children: \"Stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 361,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 336,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        opacity: 0.7,\n        marginTop: 8\n      },\n      children: session ? isSpeaking ? \"Model is speaking…\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and allow mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 366,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 16,\n        padding: 12,\n        border: \"1px solid #ddd\",\n        borderRadius: 8,\n        background: \"#fafafa\",\n        maxHeight: 280,\n        overflow: \"auto\",\n        fontFamily: \"ui-monospace, SFMono-Regular, Menlo, monospace\",\n        fontSize: 14\n      },\n      children: log.length === 0 ? /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          opacity: 0.6\n        },\n        children: \"No messages yet.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 389,\n        columnNumber: 11\n      }, this) : log.map((m, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          marginBottom: 6\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            opacity: 0.6,\n            marginRight: 8\n          },\n          children: [\"[\", m.time, \"]\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 393,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"strong\", {\n          style: {\n            textTransform: \"capitalize\"\n          },\n          children: [m.role, \":\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 394,\n          columnNumber: 15\n        }, this), \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n          children: m.text\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 395,\n          columnNumber: 15\n        }, this)]\n      }, i, true, {\n        fileName: _jsxFileName,\n        lineNumber: 392,\n        columnNumber: 13\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 375,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 325,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ixhtq0tRUgY58c9M4hEqt6TJxvI=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","INPUT_SAMPLE_RATE","App","_s","avatarRef","session","setSession","micStream","setMicStream","isSpeaking","setIsSpeaking","inputCtxRef","outputCtxRef","playQueueRef","drainingRef","voiceActiveRef","log","setLog","current","play","stop","nowHHMMSS","d","Date","pad","n","String","padStart","getHours","getMinutes","getSeconds","addLog","role","text","prev","time","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","enqueuePlayback","chunk","int16","ArrayBuffer","push","drainPlayback","window","AudioContext","webkitAudioContext","sampleRate","shift","f32","buf","createBuffer","copyToChannel","Promise","resolve","src","createBufferSource","connect","destination","start","onended","extractMessageText","msg","_sc$modelTurn","trim","sc","serverContent","output","Array","isArray","t","map","o","filter","Boolean","join","modelTurn","parts","p","candidates","_c$content","_c$content$parts","content","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onopen","onmessage","_msg$speechUpdate$aud","_msg$speechUpdate","_msg$serverContent","audio","speechUpdate","data","turnComplete","onerror","e","console","error","message","onclose","stream","navigator","mediaDevices","getUserMedia","inCtx","createMediaStreamSource","proc","createScriptProcessor","nullOut","createGain","gain","value","onaudioprocess","ch","inputBuffer","getChannelData","rms","reduce","acc","v","abs","talking","ds","pcm16","sendRealtimeInput","mimeType","stopLive","getTracks","forEach","close","_session$close","call","sendText","sendClientContent","textInput","setTextInput","className","style","maxWidth","margin","padding","children","fileName","_jsxFileName","lineNumber","columnNumber","lottieRef","animationData","loop","autoplay","height","display","gap","marginTop","onClick","flex","placeholder","onChange","target","onKeyDown","key","opacity","border","borderRadius","background","maxHeight","overflow","fontFamily","fontSize","m","marginBottom","marginRight","textTransform","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\n// ✅ Correct Live model id\nconst MODEL = \"gemini-live-2.5-flash-preview\";\n\n// Live output is 24 kHz PCM (model → you)\nconst OUTPUT_SAMPLE_RATE = 24000;\n// We’ll stream mic to model at 16 kHz PCM (you → model)\nconst INPUT_SAMPLE_RATE = 16000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // --- session & audio state ---\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Separate contexts: input (recording), output (playback @24k)\n  const inputCtxRef = useRef(null);\n  const outputCtxRef = useRef(null);\n\n  // Playback queue (sequential, no overlaps)\n  const playQueueRef = useRef([]);\n  const drainingRef = useRef(false);\n\n  // Simple VAD-ish flag for logging user “voice” once per burst\n  const voiceActiveRef = useRef(false);\n\n  // Conversation log: [{time, role:'user'|'ai'|'system', text}]\n  const [log, setLog] = useState([]);\n\n  // Drive avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();\n    else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers ----------\n\n  function nowHHMMSS() {\n    const d = new Date();\n    const pad = (n) => String(n).padStart(2, \"0\");\n    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n  }\n\n  function addLog(role, text) {\n    setLog((prev) => [...prev, { time: nowHHMMSS(), role, text }]);\n  }\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample Float32 (device rate) → 16 kHz\n  function downsampleTo16k(float32, inRate) {\n    if (inRate === INPUT_SAMPLE_RATE) return float32;\n    const ratio = inRate / INPUT_SAMPLE_RATE;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: strict FIFO @ 24 kHz (no overlaps) ----------\n\n  async function enqueuePlayback(chunk) {\n    // chunk may be base64 (most common) or ArrayBuffer (older SDKs)\n    let int16;\n    if (typeof chunk === \"string\") int16 = base64ToInt16(chunk);\n    else if (chunk instanceof ArrayBuffer) int16 = new Int16Array(chunk);\n    else return;\n\n    playQueueRef.current.push(int16);\n    if (!drainingRef.current) drainPlayback();\n  }\n\n  async function drainPlayback() {\n    drainingRef.current = true;\n\n    // lazy output context (fixed @24k for clean pitch)\n    const out =\n      outputCtxRef.current ||\n      new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: OUTPUT_SAMPLE_RATE,\n      });\n    if (!outputCtxRef.current) outputCtxRef.current = out;\n\n    while (playQueueRef.current.length) {\n      const int16 = playQueueRef.current.shift();\n\n      // Int16 → Float32\n      const f32 = new Float32Array(int16.length);\n      for (let i = 0; i < int16.length; i++) f32[i] = int16[i] / 0x8000;\n\n      // Buffer @ 24 kHz\n      const buf = out.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n      buf.copyToChannel(f32, 0);\n\n      await new Promise((resolve) => {\n        const src = out.createBufferSource();\n        src.buffer = buf;\n        src.connect(out.destination);\n        setIsSpeaking(true);\n        src.start();\n        src.onended = () => {\n          setIsSpeaking(false);\n          resolve();\n        };\n      });\n    }\n\n    drainingRef.current = false;\n  }\n\n  // Try to extract any text the SDK provides for AI turns\n  function extractMessageText(msg) {\n    // Common fields seen in preview SDKs:\n    if (typeof msg?.text === \"string\" && msg.text.trim()) return msg.text.trim();\n\n    // Some variants attach text in serverContent / modelTurn / parts\n    const sc = msg?.serverContent;\n    if (sc?.output && Array.isArray(sc.output)) {\n      const t = sc.output.map((o) => o?.text).filter(Boolean).join(\" \").trim();\n      if (t) return t;\n    }\n    if (sc?.modelTurn?.parts) {\n      const t = sc.modelTurn.parts\n        .map((p) => (typeof p?.text === \"string\" ? p.text : \"\"))\n        .join(\" \")\n        .trim();\n      if (t) return t;\n    }\n\n    // Candidates-style (older shapes)\n    if (Array.isArray(msg?.candidates)) {\n      for (const c of msg.candidates) {\n        const t = c?.content?.parts\n          ?.map((p) => (typeof p?.text === \"string\" ? p.text : \"\"))\n          .join(\" \")\n          .trim();\n        if (t) return t;\n      }\n    }\n\n    return null;\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    if (session) return; // already running\n\n    // 1) fetch ephemeral token from your Node server (v1alpha required)\n    const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(\n      (r) => r.json()\n    );\n    const ephemeralKey = typeof token === \"string\" ? token : token?.name;\n\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: { apiVersion: \"v1alpha\" }, // REQUIRED for ephemeral tokens\n    });\n\n    // 2) connect the Live session\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\", \"TEXT\"], // get audio + text for logging\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Puck\" } },\n        },\n      },\n      callbacks: {\n        onopen: () => {\n          addLog(\"system\", \"Live connected\");\n        },\n        onmessage: (msg) => {\n          // Play audio (if any) sequentially\n          const audio = msg?.speechUpdate?.audio ?? msg?.data;\n          if (audio) enqueuePlayback(audio);\n\n          // Log AI text if provided\n          const text = extractMessageText(msg);\n          if (text) addLog(\"ai\", text);\n\n          // Mark end-of-turn to stop avatar if no more audio buffers come\n          if (msg?.serverContent?.turnComplete) {\n            // let onended of the last buffer stop the avatar\n          }\n        },\n        onerror: (e) => {\n          console.error(\"Live error:\", e);\n          addLog(\"system\", `Error: ${String(e?.message || e)}`);\n        },\n        onclose: () => {\n          addLog(\"system\", \"Live session closed\");\n        },\n      },\n    });\n\n    setSession(s);\n\n    // 3) open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) capture mic frames and stream to the model\n    const inCtx = new (window.AudioContext || window.webkitAudioContext)();\n    inputCtxRef.current = inCtx;\n\n    const src = inCtx.createMediaStreamSource(stream);\n    const proc = inCtx.createScriptProcessor(4096, 1, 1);\n\n    // Keep node alive but DO NOT route mic to speakers (avoid echo/“double voice”)\n    const nullOut = inCtx.createGain();\n    nullOut.gain.value = 0;\n    src.connect(proc);\n    proc.connect(nullOut);\n    nullOut.connect(inCtx.destination);\n\n    proc.onaudioprocess = (e) => {\n      const ch = e.inputBuffer.getChannelData(0);\n\n      // naive VAD for logging a \"voice\" marker once per burst\n      const rms =\n        ch.reduce((acc, v) => acc + Math.abs(v), 0) / Math.max(1, ch.length);\n      const talking = rms > 0.02; // tweak threshold as needed\n      if (talking && !voiceActiveRef.current) {\n        voiceActiveRef.current = true;\n        addLog(\"user\", \"[voice]\");\n      } else if (!talking && voiceActiveRef.current) {\n        voiceActiveRef.current = false;\n      }\n\n      // downsample & encode to PCM16 @16k\n      const ds = downsampleTo16k(ch, inCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const b64 = arrayBufferToBase64(pcm16.buffer);\n\n      // Stream chunk to Live (correct API for JS)\n      s.sendRealtimeInput({\n        audio: { data: b64, mimeType: `audio/pcm;rate=${INPUT_SAMPLE_RATE}` },\n      });\n    };\n  };\n\n  const stopLive = async () => {\n    // stop mic tracks\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    // close input context\n    if (inputCtxRef.current) {\n      try {\n        await inputCtxRef.current.close();\n      } catch {}\n      inputCtxRef.current = null;\n    }\n    // clear playback queue & close output context\n    playQueueRef.current = [];\n    drainingRef.current = false;\n    if (outputCtxRef.current) {\n      try {\n        await outputCtxRef.current.close();\n      } catch {}\n      outputCtxRef.current = null;\n    }\n    // close session\n    if (session) {\n      try {\n        await session.close?.();\n      } catch {}\n      setSession(null);\n    }\n    setIsSpeaking(false);\n    voiceActiveRef.current = false;\n    addLog(\"system\", \"Stopped\");\n  };\n\n  // Optional: send a text turn while mic is streaming\n  const sendText = async (text) => {\n    if (!session || !text?.trim()) return;\n    addLog(\"user\", text.trim());\n    session.sendClientContent({\n      text: text.trim(),\n      turnComplete: true, // tell model to respond now\n    });\n  };\n\n  // Simple input for text messages\n  const [textInput, setTextInput] = useState(\"\");\n\n  return (\n    <div className=\"app\" style={{ maxWidth: 720, margin: \"24px auto\", padding: 16 }}>\n      <h2>Talking AI Avatar (Gemini Live)</h2>\n\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n\n      <div style={{ display: \"flex\", gap: 8, marginTop: 12 }}>\n        {!session ? (\n          <button onClick={startLive}>Start Live</button>\n        ) : (\n          <>\n            <input\n              style={{ flex: 1, padding: 8 }}\n              placeholder=\"Type a message…\"\n              value={textInput}\n              onChange={(e) => setTextInput(e.target.value)}\n              onKeyDown={(e) => {\n                if (e.key === \"Enter\") {\n                  sendText(textInput);\n                  setTextInput(\"\");\n                }\n              }}\n            />\n            <button\n              onClick={() => {\n                sendText(textInput);\n                setTextInput(\"\");\n              }}\n            >\n              Send\n            </button>\n            <button onClick={stopLive}>Stop</button>\n          </>\n        )}\n      </div>\n\n      <p style={{ opacity: 0.7, marginTop: 8 }}>\n        {session\n          ? isSpeaking\n            ? \"Model is speaking…\"\n            : \"Live connected. Speak into your mic.\"\n          : \"Click Start Live and allow mic permission.\"}\n      </p>\n\n      {/* Conversation Log */}\n      <div\n        style={{\n          marginTop: 16,\n          padding: 12,\n          border: \"1px solid #ddd\",\n          borderRadius: 8,\n          background: \"#fafafa\",\n          maxHeight: 280,\n          overflow: \"auto\",\n          fontFamily: \"ui-monospace, SFMono-Regular, Menlo, monospace\",\n          fontSize: 14,\n        }}\n      >\n        {log.length === 0 ? (\n          <div style={{ opacity: 0.6 }}>No messages yet.</div>\n        ) : (\n          log.map((m, i) => (\n            <div key={i} style={{ marginBottom: 6 }}>\n              <span style={{ opacity: 0.6, marginRight: 8 }}>[{m.time}]</span>\n              <strong style={{ textTransform: \"capitalize\" }}>{m.role}:</strong>{\" \"}\n              <span>{m.text}</span>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}