{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\n// ✅ Correct Live model id\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-live-2.5-flash-preview\";\n\n// Live output is 24 kHz PCM (model → you)\nconst OUTPUT_SAMPLE_RATE = 24000;\n// We’ll stream mic to model at 16 kHz PCM (you → model)\nconst INPUT_SAMPLE_RATE = 16000;\n\n// If you add a CRA proxy, you can switch to \"/api/ephemeral-token\"\nconst TOKEN_BASE = process.env.REACT_APP_TOKEN_BASE || \"http://localhost:8787\";\nconst TOKEN_URL = `${TOKEN_BASE}/api/ephemeral-token`;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // --- session & audio state ---\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Separate contexts: input (recording), output (playback @24k)\n  const inputCtxRef = useRef(null);\n  const outputCtxRef = useRef(null);\n\n  // Playback queue (sequential, no overlaps)\n  const playQueueRef = useRef([]);\n  const drainingRef = useRef(false);\n\n  // Simple VAD-ish flag for logging user “voice” once per burst\n  const voiceActiveRef = useRef(false);\n\n  // Conversation log: [{time, role:'user'|'ai'|'system', text}]\n  const [log, setLog] = useState([]);\n\n  // Drive avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers ----------\n\n  function nowHHMMSS() {\n    const d = new Date();\n    const pad = n => String(n).padStart(2, \"0\");\n    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n  }\n  function addLog(role, text) {\n    setLog(prev => [...prev, {\n      time: nowHHMMSS(),\n      role,\n      text\n    }]);\n  }\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample Float32 (device rate) → 16 kHz (simple decimator)\n  function downsampleTo16k(float32, inRate) {\n    if (inRate === INPUT_SAMPLE_RATE) return float32;\n    const ratio = inRate / INPUT_SAMPLE_RATE;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: strict FIFO @ 24 kHz (no overlaps) ----------\n\n  async function enqueuePlayback(chunk) {\n    // chunk may be base64 (most common) or ArrayBuffer (older SDKs)\n    let int16;\n    if (typeof chunk === \"string\") int16 = base64ToInt16(chunk);else if (chunk instanceof ArrayBuffer) int16 = new Int16Array(chunk);else return;\n    playQueueRef.current.push(int16);\n    if (!drainingRef.current) drainPlayback();\n  }\n  async function drainPlayback() {\n    drainingRef.current = true;\n\n    // lazy output context (fixed @24k for clean pitch)\n    const out = outputCtxRef.current || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!outputCtxRef.current) outputCtxRef.current = out;\n    while (playQueueRef.current.length) {\n      const int16 = playQueueRef.current.shift();\n\n      // Int16 → Float32\n      const f32 = new Float32Array(int16.length);\n      for (let i = 0; i < int16.length; i++) f32[i] = int16[i] / 0x8000;\n\n      // Buffer @ 24 kHz\n      const buf = out.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n      buf.copyToChannel(f32, 0);\n      await new Promise(resolve => {\n        const src = out.createBufferSource();\n        src.buffer = buf;\n        src.connect(out.destination);\n        setIsSpeaking(true);\n        src.start();\n        src.onended = () => {\n          setIsSpeaking(false);\n          resolve();\n        };\n      });\n    }\n    drainingRef.current = false;\n  }\n\n  // Try to extract any text the SDK provides for AI turns\n  function extractMessageText(msg) {\n    var _sc$modelTurn;\n    // Common fields seen in preview SDKs:\n    if (typeof (msg === null || msg === void 0 ? void 0 : msg.text) === \"string\" && msg.text.trim()) return msg.text.trim();\n\n    // Some variants attach text in serverContent / modelTurn / parts\n    const sc = msg === null || msg === void 0 ? void 0 : msg.serverContent;\n    if (sc !== null && sc !== void 0 && sc.output && Array.isArray(sc.output)) {\n      const t = sc.output.map(o => o === null || o === void 0 ? void 0 : o.text).filter(Boolean).join(\" \").trim();\n      if (t) return t;\n    }\n    if (sc !== null && sc !== void 0 && (_sc$modelTurn = sc.modelTurn) !== null && _sc$modelTurn !== void 0 && _sc$modelTurn.parts) {\n      const t = sc.modelTurn.parts.map(p => typeof (p === null || p === void 0 ? void 0 : p.text) === \"string\" ? p.text : \"\").join(\" \").trim();\n      if (t) return t;\n    }\n\n    // Candidates-style (older shapes)\n    if (Array.isArray(msg === null || msg === void 0 ? void 0 : msg.candidates)) {\n      for (const c of msg.candidates) {\n        var _c$content, _c$content$parts;\n        const t = c === null || c === void 0 ? void 0 : (_c$content = c.content) === null || _c$content === void 0 ? void 0 : (_c$content$parts = _c$content.parts) === null || _c$content$parts === void 0 ? void 0 : _c$content$parts.map(p => typeof (p === null || p === void 0 ? void 0 : p.text) === \"string\" ? p.text : \"\").join(\" \").trim();\n        if (t) return t;\n      }\n    }\n    return null;\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    if (session) return; // already running\n\n    // 1) fetch ephemeral token from your Node server (v1alpha required)\n    const res = await fetch(TOKEN_URL);\n    const json = await res.json();\n    const tokenVal = json === null || json === void 0 ? void 0 : json.token;\n    const ephemeralKey = typeof tokenVal === \"string\" ? tokenVal : tokenVal === null || tokenVal === void 0 ? void 0 : tokenVal.name;\n    if (!ephemeralKey) {\n      addLog(\"system\", \"Failed to fetch ephemeral token\");\n      return;\n    }\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      } // REQUIRED for ephemeral tokens\n    });\n\n    // 2) connect the Live session\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\", \"TEXT\"],\n        // get audio + text for logging\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: {\n            prebuiltVoiceConfig: {\n              voiceName: \"Puck\"\n            }\n          }\n        }\n      },\n      callbacks: {\n        onopen: () => {\n          addLog(\"system\", \"Live connected\");\n        },\n        onmessage: msg => {\n          var _msg$speechUpdate$aud, _msg$speechUpdate;\n          // Play audio (if any) sequentially\n          const audio = (_msg$speechUpdate$aud = msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) !== null && _msg$speechUpdate$aud !== void 0 ? _msg$speechUpdate$aud : msg === null || msg === void 0 ? void 0 : msg.data;\n          if (audio) enqueuePlayback(audio);\n\n          // Log AI text if provided\n          const text = extractMessageText(msg);\n          if (text) addLog(\"ai\", text);\n\n          // If msg.serverContent.turnComplete appears, onended of last buffer will stop avatar\n        },\n        onerror: e => {\n          console.error(\"Live error:\", e);\n          addLog(\"system\", `Error: ${String((e === null || e === void 0 ? void 0 : e.message) || e)}`);\n        },\n        onclose: () => {\n          addLog(\"system\", \"Live session closed\");\n        }\n      }\n    });\n    setSession(s);\n\n    // 3) open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) capture mic frames and stream to the model\n    const inCtx = new (window.AudioContext || window.webkitAudioContext)();\n    inputCtxRef.current = inCtx;\n    const src = inCtx.createMediaStreamSource(stream);\n    const proc = inCtx.createScriptProcessor(4096, 1, 1);\n\n    // Keep node alive but DO NOT route mic to speakers (avoid echo/“double voice”)\n    const nullOut = inCtx.createGain();\n    nullOut.gain.value = 0;\n    src.connect(proc);\n    proc.connect(nullOut);\n    nullOut.connect(inCtx.destination);\n    proc.onaudioprocess = e => {\n      const ch = e.inputBuffer.getChannelData(0);\n\n      // naive VAD for logging a \"voice\" marker once per burst\n      const rms = ch.reduce((acc, v) => acc + Math.abs(v), 0) / Math.max(1, ch.length);\n      const talking = rms > 0.02; // tweak threshold as needed\n      if (talking && !voiceActiveRef.current) {\n        voiceActiveRef.current = true;\n        addLog(\"user\", \"[voice]\");\n      } else if (!talking && voiceActiveRef.current) {\n        voiceActiveRef.current = false;\n      }\n\n      // downsample & encode to PCM16 @16k\n      const ds = downsampleTo16k(ch, inCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const b64 = arrayBufferToBase64(pcm16.buffer);\n\n      // Stream chunk to Live (correct API for JS)\n      s.sendRealtimeInput({\n        audio: {\n          data: b64,\n          mimeType: `audio/pcm;rate=${INPUT_SAMPLE_RATE}`\n        }\n      });\n    };\n  };\n  const stopLive = async () => {\n    // stop mic tracks\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    // close input context\n    if (inputCtxRef.current) {\n      try {\n        await inputCtxRef.current.close();\n      } catch {}\n      inputCtxRef.current = null;\n    }\n    // clear playback queue & close output context\n    playQueueRef.current = [];\n    drainingRef.current = false;\n    if (outputCtxRef.current) {\n      try {\n        await outputCtxRef.current.close();\n      } catch {}\n      outputCtxRef.current = null;\n    }\n    // close session\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    setIsSpeaking(false);\n    voiceActiveRef.current = false;\n    addLog(\"system\", \"Stopped\");\n  };\n\n  // Optional: send a text turn while mic is streaming\n  const [textInput, setTextInput] = useState(\"\");\n  const sendText = async text => {\n    if (!session || !(text !== null && text !== void 0 && text.trim())) return;\n    const clean = text.trim();\n    addLog(\"user\", clean);\n    session.sendClientContent({\n      text: clean,\n      turnComplete: true // tell model to respond now\n    });\n  };\n\n  // Cleanup on tab close\n  useEffect(() => {\n    const onUnload = () => {\n      try {\n        stopLive();\n      } catch {}\n    };\n    window.addEventListener(\"beforeunload\", onUnload);\n    return () => window.removeEventListener(\"beforeunload\", onUnload);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [session, micStream]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    style: {\n      maxWidth: 720,\n      margin: \"24px auto\",\n      padding: 16\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Talking AI Avatar (Gemini Live)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 340,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 342,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginTop: 12\n      },\n      children: !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startLive,\n        children: \"Start Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 352,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          style: {\n            flex: 1,\n            padding: 8\n          },\n          placeholder: \"Type a message\\u2026\",\n          value: textInput,\n          onChange: e => setTextInput(e.target.value),\n          onKeyDown: e => {\n            if (e.key === \"Enter\") {\n              sendText(textInput);\n              setTextInput(\"\");\n            }\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 355,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            sendText(textInput);\n            setTextInput(\"\");\n          },\n          children: \"Send\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 367,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: stopLive,\n          children: \"Stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 375,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        opacity: 0.7,\n        marginTop: 8\n      },\n      children: session ? isSpeaking ? \"Model is speaking…\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and allow mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 380,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 16,\n        padding: 12,\n        border: \"1px solid #ddd\",\n        borderRadius: 8,\n        background: \"#fafafa\",\n        maxHeight: 280,\n        overflow: \"auto\",\n        fontFamily: \"ui-monospace, SFMono-Regular, Menlo, monospace\",\n        fontSize: 14\n      },\n      children: log.length === 0 ? /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          opacity: 0.6\n        },\n        children: \"No messages yet.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 403,\n        columnNumber: 11\n      }, this) : log.map((m, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          marginBottom: 6\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            opacity: 0.6,\n            marginRight: 8\n          },\n          children: [\"[\", m.time, \"]\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 407,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"strong\", {\n          style: {\n            textTransform: \"capitalize\"\n          },\n          children: [m.role, \":\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 408,\n          columnNumber: 15\n        }, this), \" \", /*#__PURE__*/_jsxDEV(\"span\", {\n          children: m.text\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 409,\n          columnNumber: 15\n        }, this)]\n      }, i, true, {\n        fileName: _jsxFileName,\n        lineNumber: 406,\n        columnNumber: 13\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 389,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 339,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"nZt4oIQ+7b3UbsjhfIeeDdaAOVA=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","INPUT_SAMPLE_RATE","TOKEN_BASE","process","env","REACT_APP_TOKEN_BASE","TOKEN_URL","App","_s","avatarRef","session","setSession","micStream","setMicStream","isSpeaking","setIsSpeaking","inputCtxRef","outputCtxRef","playQueueRef","drainingRef","voiceActiveRef","log","setLog","current","play","stop","nowHHMMSS","d","Date","pad","n","String","padStart","getHours","getMinutes","getSeconds","addLog","role","text","prev","time","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","enqueuePlayback","chunk","int16","ArrayBuffer","push","drainPlayback","window","AudioContext","webkitAudioContext","sampleRate","shift","f32","buf","createBuffer","copyToChannel","Promise","resolve","src","createBufferSource","connect","destination","start","onended","extractMessageText","msg","_sc$modelTurn","trim","sc","serverContent","output","Array","isArray","t","map","o","filter","Boolean","join","modelTurn","parts","p","candidates","_c$content","_c$content$parts","content","startLive","res","fetch","json","tokenVal","token","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onopen","onmessage","_msg$speechUpdate$aud","_msg$speechUpdate","audio","speechUpdate","data","onerror","e","console","error","message","onclose","stream","navigator","mediaDevices","getUserMedia","inCtx","createMediaStreamSource","proc","createScriptProcessor","nullOut","createGain","gain","value","onaudioprocess","ch","inputBuffer","getChannelData","rms","reduce","acc","v","abs","talking","ds","pcm16","sendRealtimeInput","mimeType","stopLive","getTracks","forEach","close","_session$close","call","textInput","setTextInput","sendText","clean","sendClientContent","turnComplete","onUnload","addEventListener","removeEventListener","className","style","maxWidth","margin","padding","children","fileName","_jsxFileName","lineNumber","columnNumber","lottieRef","animationData","loop","autoplay","height","display","gap","marginTop","onClick","flex","placeholder","onChange","target","onKeyDown","key","opacity","border","borderRadius","background","maxHeight","overflow","fontFamily","fontSize","m","marginBottom","marginRight","textTransform","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\n// ✅ Correct Live model id\nconst MODEL = \"gemini-live-2.5-flash-preview\";\n\n// Live output is 24 kHz PCM (model → you)\nconst OUTPUT_SAMPLE_RATE = 24000;\n// We’ll stream mic to model at 16 kHz PCM (you → model)\nconst INPUT_SAMPLE_RATE = 16000;\n\n// If you add a CRA proxy, you can switch to \"/api/ephemeral-token\"\nconst TOKEN_BASE = process.env.REACT_APP_TOKEN_BASE || \"http://localhost:8787\";\nconst TOKEN_URL = `${TOKEN_BASE}/api/ephemeral-token`;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // --- session & audio state ---\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Separate contexts: input (recording), output (playback @24k)\n  const inputCtxRef = useRef(null);\n  const outputCtxRef = useRef(null);\n\n  // Playback queue (sequential, no overlaps)\n  const playQueueRef = useRef([]);\n  const drainingRef = useRef(false);\n\n  // Simple VAD-ish flag for logging user “voice” once per burst\n  const voiceActiveRef = useRef(false);\n\n  // Conversation log: [{time, role:'user'|'ai'|'system', text}]\n  const [log, setLog] = useState([]);\n\n  // Drive avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();\n    else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers ----------\n\n  function nowHHMMSS() {\n    const d = new Date();\n    const pad = (n) => String(n).padStart(2, \"0\");\n    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n  }\n\n  function addLog(role, text) {\n    setLog((prev) => [...prev, { time: nowHHMMSS(), role, text }]);\n  }\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample Float32 (device rate) → 16 kHz (simple decimator)\n  function downsampleTo16k(float32, inRate) {\n    if (inRate === INPUT_SAMPLE_RATE) return float32;\n    const ratio = inRate / INPUT_SAMPLE_RATE;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: strict FIFO @ 24 kHz (no overlaps) ----------\n\n  async function enqueuePlayback(chunk) {\n    // chunk may be base64 (most common) or ArrayBuffer (older SDKs)\n    let int16;\n    if (typeof chunk === \"string\") int16 = base64ToInt16(chunk);\n    else if (chunk instanceof ArrayBuffer) int16 = new Int16Array(chunk);\n    else return;\n\n    playQueueRef.current.push(int16);\n    if (!drainingRef.current) drainPlayback();\n  }\n\n  async function drainPlayback() {\n    drainingRef.current = true;\n\n    // lazy output context (fixed @24k for clean pitch)\n    const out =\n      outputCtxRef.current ||\n      new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: OUTPUT_SAMPLE_RATE,\n      });\n    if (!outputCtxRef.current) outputCtxRef.current = out;\n\n    while (playQueueRef.current.length) {\n      const int16 = playQueueRef.current.shift();\n\n      // Int16 → Float32\n      const f32 = new Float32Array(int16.length);\n      for (let i = 0; i < int16.length; i++) f32[i] = int16[i] / 0x8000;\n\n      // Buffer @ 24 kHz\n      const buf = out.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n      buf.copyToChannel(f32, 0);\n\n      await new Promise((resolve) => {\n        const src = out.createBufferSource();\n        src.buffer = buf;\n        src.connect(out.destination);\n        setIsSpeaking(true);\n        src.start();\n        src.onended = () => {\n          setIsSpeaking(false);\n          resolve();\n        };\n      });\n    }\n\n    drainingRef.current = false;\n  }\n\n  // Try to extract any text the SDK provides for AI turns\n  function extractMessageText(msg) {\n    // Common fields seen in preview SDKs:\n    if (typeof msg?.text === \"string\" && msg.text.trim()) return msg.text.trim();\n\n    // Some variants attach text in serverContent / modelTurn / parts\n    const sc = msg?.serverContent;\n    if (sc?.output && Array.isArray(sc.output)) {\n      const t = sc.output.map((o) => o?.text).filter(Boolean).join(\" \").trim();\n      if (t) return t;\n    }\n    if (sc?.modelTurn?.parts) {\n      const t = sc.modelTurn.parts\n        .map((p) => (typeof p?.text === \"string\" ? p.text : \"\"))\n        .join(\" \")\n        .trim();\n      if (t) return t;\n    }\n\n    // Candidates-style (older shapes)\n    if (Array.isArray(msg?.candidates)) {\n      for (const c of msg.candidates) {\n        const t = c?.content?.parts\n          ?.map((p) => (typeof p?.text === \"string\" ? p.text : \"\"))\n          .join(\" \")\n          .trim();\n        if (t) return t;\n      }\n    }\n\n    return null;\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    if (session) return; // already running\n\n    // 1) fetch ephemeral token from your Node server (v1alpha required)\n    const res = await fetch(TOKEN_URL);\n    const json = await res.json();\n    const tokenVal = json?.token;\n    const ephemeralKey = typeof tokenVal === \"string\" ? tokenVal : tokenVal?.name;\n\n    if (!ephemeralKey) {\n      addLog(\"system\", \"Failed to fetch ephemeral token\");\n      return;\n    }\n\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: { apiVersion: \"v1alpha\" } // REQUIRED for ephemeral tokens\n    });\n\n    // 2) connect the Live session\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\", \"TEXT\"], // get audio + text for logging\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Puck\" } },\n        },\n      },\n      callbacks: {\n        onopen: () => {\n          addLog(\"system\", \"Live connected\");\n        },\n        onmessage: (msg) => {\n          // Play audio (if any) sequentially\n          const audio = msg?.speechUpdate?.audio ?? msg?.data;\n          if (audio) enqueuePlayback(audio);\n\n          // Log AI text if provided\n          const text = extractMessageText(msg);\n          if (text) addLog(\"ai\", text);\n\n          // If msg.serverContent.turnComplete appears, onended of last buffer will stop avatar\n        },\n        onerror: (e) => {\n          console.error(\"Live error:\", e);\n          addLog(\"system\", `Error: ${String(e?.message || e)}`);\n        },\n        onclose: () => {\n          addLog(\"system\", \"Live session closed\");\n        },\n      },\n    });\n\n    setSession(s);\n\n    // 3) open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) capture mic frames and stream to the model\n    const inCtx = new (window.AudioContext || window.webkitAudioContext)();\n    inputCtxRef.current = inCtx;\n\n    const src = inCtx.createMediaStreamSource(stream);\n    const proc = inCtx.createScriptProcessor(4096, 1, 1);\n\n    // Keep node alive but DO NOT route mic to speakers (avoid echo/“double voice”)\n    const nullOut = inCtx.createGain();\n    nullOut.gain.value = 0;\n    src.connect(proc);\n    proc.connect(nullOut);\n    nullOut.connect(inCtx.destination);\n\n    proc.onaudioprocess = (e) => {\n      const ch = e.inputBuffer.getChannelData(0);\n\n      // naive VAD for logging a \"voice\" marker once per burst\n      const rms =\n        ch.reduce((acc, v) => acc + Math.abs(v), 0) / Math.max(1, ch.length);\n      const talking = rms > 0.02; // tweak threshold as needed\n      if (talking && !voiceActiveRef.current) {\n        voiceActiveRef.current = true;\n        addLog(\"user\", \"[voice]\");\n      } else if (!talking && voiceActiveRef.current) {\n        voiceActiveRef.current = false;\n      }\n\n      // downsample & encode to PCM16 @16k\n      const ds = downsampleTo16k(ch, inCtx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n      const b64 = arrayBufferToBase64(pcm16.buffer);\n\n      // Stream chunk to Live (correct API for JS)\n      s.sendRealtimeInput({\n        audio: { data: b64, mimeType: `audio/pcm;rate=${INPUT_SAMPLE_RATE}` },\n      });\n    };\n  };\n\n  const stopLive = async () => {\n    // stop mic tracks\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    // close input context\n    if (inputCtxRef.current) {\n      try {\n        await inputCtxRef.current.close();\n      } catch {}\n      inputCtxRef.current = null;\n    }\n    // clear playback queue & close output context\n    playQueueRef.current = [];\n    drainingRef.current = false;\n    if (outputCtxRef.current) {\n      try {\n        await outputCtxRef.current.close();\n      } catch {}\n      outputCtxRef.current = null;\n    }\n    // close session\n    if (session) {\n      try {\n        await session.close?.();\n      } catch {}\n      setSession(null);\n    }\n    setIsSpeaking(false);\n    voiceActiveRef.current = false;\n    addLog(\"system\", \"Stopped\");\n  };\n\n  // Optional: send a text turn while mic is streaming\n  const [textInput, setTextInput] = useState(\"\");\n  const sendText = async (text) => {\n    if (!session || !text?.trim()) return;\n    const clean = text.trim();\n    addLog(\"user\", clean);\n    session.sendClientContent({\n      text: clean,\n      turnComplete: true, // tell model to respond now\n    });\n  };\n\n  // Cleanup on tab close\n  useEffect(() => {\n    const onUnload = () => {\n      try { stopLive(); } catch {}\n    };\n    window.addEventListener(\"beforeunload\", onUnload);\n    return () => window.removeEventListener(\"beforeunload\", onUnload);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [session, micStream]);\n\n  return (\n    <div className=\"app\" style={{ maxWidth: 720, margin: \"24px auto\", padding: 16 }}>\n      <h2>Talking AI Avatar (Gemini Live)</h2>\n\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n\n      <div style={{ display: \"flex\", gap: 8, marginTop: 12 }}>\n        {!session ? (\n          <button onClick={startLive}>Start Live</button>\n        ) : (\n          <>\n            <input\n              style={{ flex: 1, padding: 8 }}\n              placeholder=\"Type a message…\"\n              value={textInput}\n              onChange={(e) => setTextInput(e.target.value)}\n              onKeyDown={(e) => {\n                if (e.key === \"Enter\") {\n                  sendText(textInput);\n                  setTextInput(\"\");\n                }\n              }}\n            />\n            <button\n              onClick={() => {\n                sendText(textInput);\n                setTextInput(\"\");\n              }}\n            >\n              Send\n            </button>\n            <button onClick={stopLive}>Stop</button>\n          </>\n        )}\n      </div>\n\n      <p style={{ opacity: 0.7, marginTop: 8 }}>\n        {session\n          ? isSpeaking\n            ? \"Model is speaking…\"\n            : \"Live connected. Speak into your mic.\"\n          : \"Click Start Live and allow mic permission.\"}\n      </p>\n\n      {/* Conversation Log */}\n      <div\n        style={{\n          marginTop: 16,\n          padding: 12,\n          border: \"1px solid #ddd\",\n          borderRadius: 8,\n          background: \"#fafafa\",\n          maxHeight: 280,\n          overflow: \"auto\",\n          fontFamily: \"ui-monospace, SFMono-Regular, Menlo, monospace\",\n          fontSize: 14,\n        }}\n      >\n        {log.length === 0 ? (\n          <div style={{ opacity: 0.6 }}>No messages yet.</div>\n        ) : (\n          log.map((m, i) => (\n            <div key={i} style={{ marginBottom: 6 }}>\n              <span style={{ opacity: 0.6, marginRight: 8 }}>[{m.time}]</span>\n              <strong style={{ textTransform: \"capitalize\" }}>{m.role}:</strong>{\" \"}\n              <span>{m.text}</span>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}