{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI, Modality } from \"@google/genai\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-2.5-flash-live-preview\"; // correct Live model\n// Live output is 24 kHz PCM. We'll create a 24k AudioContext for clean playback.\nconst OUTPUT_SAMPLE_RATE = 24000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // Convert Float32Array PCM (from WebAudio) to Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Simple downsampler to 16k (Live will resample if needed; we include the rate in MIME)\n  // You can skip this and send device rate; just set the right MIME (e.g., audio/pcm;rate=48000)\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // Play a chunk of 24k PCM Int16 from the model\n  async function playPCM24k(int16le) {\n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n    setIsSpeaking(true);\n    src.start();\n    src.onended = () => setIsSpeaking(false);\n  }\n\n  // Start a Live session and begin mic streaming\n  const startLive = async () => {\n    // 1) Ask server for ephemeral token\n\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n\n    // Some servers return {token: \"authTokens/...\"} and some return {token: {name: \"authTokens/...\"}}\n    const ephemeralKey = typeof token === 'string' ? token : token === null || token === void 0 ? void 0 : token.name;\n\n    // IMPORTANT: Ephemeral tokens require v1alpha on the client\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: 'v1alpha'\n      } // <- key line\n    });\n    const s = await ai.live.connect({\n      model: \"gemini-live-2.5-flash-preview\",\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: {\n            prebuiltVoiceConfig: {\n              voiceName: \"Puck\"\n            }\n          }\n        }\n      },\n      callbacks: {\n        onmessage: msg => {\n          var _msg$speechUpdate;\n          const audioBuf = (msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) || (msg === null || msg === void 0 ? void 0 : msg.data) || null;\n          if (audioBuf instanceof ArrayBuffer) {\n            const int16 = new Int16Array(audioBuf);\n            playPCM24k(int16);\n          }\n        },\n        onerror: e => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\")\n      }\n    });\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1); // simple; AudioWorklet is nicer for prod\n    src.connect(proc);\n    proc.connect(ctx.destination); // (or ctx.createGain() to avoid feedback)\n\n    proc.onaudioprocess = e => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      // Optional: downsample to 16k; otherwise use device rate and set MIME accordingly\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n\n      // IMPORTANT: specify sample rate in MIME so Live knows how to interpret it\n      const mime = \"audio/pcm;rate=16000\";\n      // The SDK preview accepted a simple \"send\" with binary chunks:\n      s.send({\n        data: pcm16.buffer,\n        mimeType: mime\n      });\n      // If your SDK version prefers a more explicit method, use:\n      // s.sendClientContent({ audio: { data: pcm16.buffer, mimeType: mime } });\n    };\n  };\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async text => {\n    if (!session) return;\n    // Preview SDK supported a generic send with { input, endOfTurn }\n    session.send({\n      input: text,\n      endOfTurn: true\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Talking AI Avatar (Gemini Live)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginTop: 12\n      },\n      children: !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startLive,\n        children: \"Start Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 177,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => sendText(\"नमस्ते! आप कैसे हैं?\"),\n          children: \"Send Text Turn\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 180,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: stopLive,\n          children: \"Stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 183,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 175,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        opacity: .7,\n        marginTop: 8\n      },\n      children: session ? isSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and give mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 188,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 164,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"K+h1czJ5QEBnJ7+PHKcczj8dIUw=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useMemo","useRef","useState","Lottie","talkingAvatar","GoogleGenAI","Modality","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","App","_s","avatarRef","session","setSession","audioCtx","setAudioCtx","micStream","setMicStream","isSpeaking","setIsSpeaking","current","play","stop","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","outRate","ratio","newLen","floor","Float32Array","pos","playPCM24k","int16le","ctx","window","AudioContext","webkitAudioContext","sampleRate","f32","buffer","createBuffer","copyToChannel","src","createBufferSource","connect","destination","start","onended","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onmessage","msg","_msg$speechUpdate","audioBuf","speechUpdate","audio","data","ArrayBuffer","int16","onerror","e","console","error","onclose","log","stream","navigator","mediaDevices","getUserMedia","createMediaStreamSource","proc","createScriptProcessor","onaudioprocess","inBuf","inputBuffer","getChannelData","ds","pcm16","mime","send","mimeType","stopLive","getTracks","forEach","t","_session$close","close","call","sendText","text","input","endOfTurn","className","children","fileName","_jsxFileName","lineNumber","columnNumber","lottieRef","animationData","loop","autoplay","style","height","display","gap","marginTop","onClick","opacity","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI, Modality } from \"@google/genai\";\n\nconst MODEL = \"gemini-2.5-flash-live-preview\"; // correct Live model\n// Live output is 24 kHz PCM. We'll create a 24k AudioContext for clean playback.\nconst OUTPUT_SAMPLE_RATE = 24000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();\n    else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // Convert Float32Array PCM (from WebAudio) to Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Simple downsampler to 16k (Live will resample if needed; we include the rate in MIME)\n  // You can skip this and send device rate; just set the right MIME (e.g., audio/pcm;rate=48000)\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // Play a chunk of 24k PCM Int16 from the model\n  async function playPCM24k(int16le) {\n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({ sampleRate: OUTPUT_SAMPLE_RATE });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n\n    setIsSpeaking(true);\n    src.start();\n    src.onended = () => setIsSpeaking(false);\n  }\n\n  // Start a Live session and begin mic streaming\n  const startLive = async () => {\n    // 1) Ask server for ephemeral token\n \n  const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n\n  // Some servers return {token: \"authTokens/...\"} and some return {token: {name: \"authTokens/...\"}}\n  const ephemeralKey = typeof token === 'string' ? token : token?.name;\n\n  // IMPORTANT: Ephemeral tokens require v1alpha on the client\n const ai = new GoogleGenAI({\n  apiKey: ephemeralKey,\n  httpOptions: { apiVersion: 'v1alpha' }, // <- key line\n});\n\n    const s = await ai.live.connect({\n      model: \"gemini-live-2.5-flash-preview\",\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Puck\" } },\n        },\n      },\n      callbacks: {\n        onmessage: (msg) => {\n          const audioBuf = msg?.speechUpdate?.audio || msg?.data || null;\n          if (audioBuf instanceof ArrayBuffer) {\n            const int16 = new Int16Array(audioBuf);\n            playPCM24k(int16);\n          }\n        },\n        onerror: (e) => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\"),\n      },\n    });\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1); // simple; AudioWorklet is nicer for prod\n    src.connect(proc);\n    proc.connect(ctx.destination); // (or ctx.createGain() to avoid feedback)\n\n    proc.onaudioprocess = (e) => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      // Optional: downsample to 16k; otherwise use device rate and set MIME accordingly\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n\n      // IMPORTANT: specify sample rate in MIME so Live knows how to interpret it\n      const mime = \"audio/pcm;rate=16000\";\n      // The SDK preview accepted a simple \"send\" with binary chunks:\n      s.send({ data: pcm16.buffer, mimeType: mime });\n      // If your SDK version prefers a more explicit method, use:\n      // s.sendClientContent({ audio: { data: pcm16.buffer, mimeType: mime } });\n    };\n  };\n\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try { await session.close?.(); } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try { await audioCtx.close(); } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async (text) => {\n    if (!session) return;\n    // Preview SDK supported a generic send with { input, endOfTurn }\n    session.send({ input: text, endOfTurn: true });\n  };\n\n  return (\n    <div className=\"app\">\n      <h2>Talking AI Avatar (Gemini Live)</h2>\n\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n\n      <div style={{ display: \"flex\", gap: 8, marginTop: 12 }}>\n        {!session ? (\n          <button onClick={startLive}>Start Live</button>\n        ) : (\n          <>\n            <button onClick={() => sendText(\"नमस्ते! आप कैसे हैं?\")}>\n              Send Text Turn\n            </button>\n            <button onClick={stopLive}>Stop</button>\n          </>\n        )}\n      </div>\n\n      <p style={{opacity: .7, marginTop: 8}}>\n        {session\n          ? (isSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\")\n          : \"Click Start Live and give mic permission.\"}\n      </p>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}