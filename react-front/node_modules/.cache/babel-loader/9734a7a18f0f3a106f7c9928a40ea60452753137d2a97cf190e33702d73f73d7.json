{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\n\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-1.5-flash-latest\";\nconst OUTPUT_SAMPLE_RATE = 24000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // State\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const [history, setHistory] = useState([]);\n\n  // Refs for audio processing and queue\n  const audioQueue = useRef([]);\n  const isPlaybackActive = useRef(false);\n  // *** NEW: Ref to hold audio processing nodes ***\n  const audioProcessingRef = useRef({\n    ctx: null,\n    proc: null,\n    src: null\n  });\n\n  // (useEffect for avatar animation remains the same)\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // (Audio helpers, queue logic, and history logic remain the same)\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n  const processQueue = useCallback(() => {\n    if (audioQueue.current.length === 0 || isPlaybackActive.current) return;\n    isPlaybackActive.current = true;\n    setIsSpeaking(true);\n    const int16le = audioQueue.current.shift();\n    const mainAudioCtx = audioProcessingRef.current.ctx || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!audioProcessingRef.current.ctx) audioProcessingRef.current.ctx = mainAudioCtx;\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) f32[i] = int16le[i] / 0x8000;\n    const buffer = mainAudioCtx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = mainAudioCtx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(mainAudioCtx.destination);\n    src.onended = () => {\n      isPlaybackActive.current = false;\n      if (audioQueue.current.length === 0) setIsSpeaking(false);\n      processQueue();\n    };\n    src.start();\n  }, []);\n  const addToHistory = (role, text) => {\n    const timestamp = new Date().toLocaleTimeString();\n    setHistory(prev => [...prev, {\n      role,\n      text,\n      timestamp\n    }]);\n  };\n  const startLive = async () => {\n    // (Reset state remains the same)\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n    setHistory([]);\n\n    // (Token fetching and session connection remains the same)\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n    const ephemeralKey = typeof token === \"string\" ? token : token === null || token === void 0 ? void 0 : token.name;\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      }\n    });\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\", \"TEXT\"]\n      },\n      speechConfig: {\n        languageCode: \"hi-IN\",\n        voiceConfig: {\n          prebuiltVoiceConfig: {\n            voiceName: \"Kore\"\n          }\n        }\n      },\n      callbacks: {\n        onmessage: msg => {\n          var _msg$speechUpdate, _msg$speechUpdate2, _msg$speechUpdate3;\n          const base64Audio = (msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) || (msg === null || msg === void 0 ? void 0 : msg.data) || null;\n          if (typeof base64Audio === \"string\") {\n            audioQueue.current.push(base64ToInt16(base64Audio));\n            processQueue();\n          }\n          const transcript = msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate2 = msg.speechUpdate) === null || _msg$speechUpdate2 === void 0 ? void 0 : _msg$speechUpdate2.transcript;\n          if (transcript && msg !== null && msg !== void 0 && (_msg$speechUpdate3 = msg.speechUpdate) !== null && _msg$speechUpdate3 !== void 0 && _msg$speechUpdate3.isFinal) {\n            addToHistory(\"Human\", transcript);\n          }\n        },\n        onerror: e => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\")\n      }\n    });\n    setSession(s);\n\n    // Open mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // *** FIX: Store audio nodes in the ref ***\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1);\n\n    // Save nodes to ref\n    audioProcessingRef.current = {\n      ctx,\n      src,\n      proc\n    };\n    src.connect(proc);\n    proc.connect(ctx.destination);\n    proc.onaudioprocess = e => {\n      // Check if session is still active before sending\n      if (s && !s.isClosed) {\n        const inBuf = e.inputBuffer.getChannelData(0);\n        const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n        const pcm16 = floatTo16BitPCM(ds);\n        const mime = \"audio/pcm;rate=16000\";\n        s.sendRealtimeInput({\n          audio: {\n            data: arrayBufferToBase64(pcm16.buffer),\n            mimeType: mime\n          }\n        });\n      }\n    };\n  };\n  const stopLive = async () => {\n    // *** FIX: New ordered cleanup logic ***\n\n    // 1. Stop the audio processor from sending any more data\n    const {\n      proc,\n      src,\n      ctx\n    } = audioProcessingRef.current;\n    if (proc) {\n      proc.disconnect();\n      proc.onaudioprocess = null; // Remove the handler\n    }\n    if (src) {\n      src.disconnect();\n    }\n\n    // 2. Stop the microphone track\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n\n    // 3. NOW it's safe to close the session\n    if (session) {\n      var _session$close;\n      await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session).catch(() => {}));\n      setSession(null);\n    }\n\n    // 4. Close the audio context\n    if (ctx) {\n      await ctx.close().catch(() => {});\n    }\n\n    // 5. Reset all state\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n    audioProcessingRef.current = {};\n  };\n  const sendText = async text => {\n    if (!session) return;\n    addToHistory(\"AI\", text);\n    session.sendClientContent({\n      text,\n      turnComplete: true\n    });\n  };\n\n  // (Render method remains the same)\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 202,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"UrGOBcuclrYfeQgIOzd0dLn93gA=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","MODEL","OUTPUT_SAMPLE_RATE","App","_s","avatarRef","session","setSession","micStream","setMicStream","isSpeaking","setIsSpeaking","history","setHistory","audioQueue","isPlaybackActive","audioProcessingRef","ctx","proc","src","current","play","stop","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","outRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","String","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","processQueue","int16le","shift","mainAudioCtx","window","AudioContext","webkitAudioContext","sampleRate","f32","createBuffer","copyToChannel","createBufferSource","connect","destination","onended","start","addToHistory","role","text","timestamp","Date","toLocaleTimeString","prev","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onmessage","msg","_msg$speechUpdate","_msg$speechUpdate2","_msg$speechUpdate3","base64Audio","speechUpdate","audio","data","push","transcript","isFinal","onerror","e","console","error","onclose","log","stream","navigator","mediaDevices","getUserMedia","createMediaStreamSource","createScriptProcessor","onaudioprocess","isClosed","inBuf","inputBuffer","getChannelData","ds","pcm16","mime","sendRealtimeInput","mimeType","stopLive","disconnect","getTracks","forEach","t","_session$close","close","call","catch","sendText","sendClientContent","turnComplete","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\n\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL = \"gemini-1.5-flash-latest\";\nconst OUTPUT_SAMPLE_RATE = 24000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // State\n  const [session, setSession] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const [history, setHistory] = useState([]);\n\n  // Refs for audio processing and queue\n  const audioQueue = useRef([]);\n  const isPlaybackActive = useRef(false);\n  // *** NEW: Ref to hold audio processing nodes ***\n  const audioProcessingRef = useRef({\n    ctx: null,\n    proc: null,\n    src: null,\n  });\n\n  // (useEffect for avatar animation remains the same)\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();\n    else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n\n  // (Audio helpers, queue logic, and history logic remain the same)\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n  const processQueue = useCallback(() => {\n    if (audioQueue.current.length === 0 || isPlaybackActive.current) return;\n    isPlaybackActive.current = true;\n    setIsSpeaking(true);\n    const int16le = audioQueue.current.shift();\n    const mainAudioCtx = audioProcessingRef.current.ctx || new (window.AudioContext || window.webkitAudioContext)({ sampleRate: OUTPUT_SAMPLE_RATE });\n    if (!audioProcessingRef.current.ctx) audioProcessingRef.current.ctx = mainAudioCtx;\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) f32[i] = int16le[i] / 0x8000;\n    const buffer = mainAudioCtx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = mainAudioCtx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(mainAudioCtx.destination);\n    src.onended = () => {\n      isPlaybackActive.current = false;\n      if (audioQueue.current.length === 0) setIsSpeaking(false);\n      processQueue();\n    };\n    src.start();\n  }, []);\n  const addToHistory = (role, text) => {\n    const timestamp = new Date().toLocaleTimeString();\n    setHistory(prev => [...prev, { role, text, timestamp }]);\n  };\n\n\n  const startLive = async () => {\n    // (Reset state remains the same)\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n    setHistory([]);\n\n    // (Token fetching and session connection remains the same)\n    const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then((r) => r.json());\n    const ephemeralKey = typeof token === \"string\" ? token : token?.name;\n    const ai = new GoogleGenAI({ apiKey: ephemeralKey, httpOptions: { apiVersion: \"v1alpha\" } });\n    const s = await ai.live.connect({\n        model: MODEL,\n        config: { responseModalities: [\"AUDIO\", \"TEXT\"] },\n        speechConfig: { languageCode: \"hi-IN\", voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Kore\" } } },\n        callbacks: {\n            onmessage: (msg) => {\n                const base64Audio = msg?.speechUpdate?.audio || msg?.data || null;\n                if (typeof base64Audio === \"string\") {\n                    audioQueue.current.push(base64ToInt16(base64Audio));\n                    processQueue();\n                }\n                const transcript = msg?.speechUpdate?.transcript;\n                if (transcript && msg?.speechUpdate?.isFinal) {\n                    addToHistory(\"Human\", transcript);\n                }\n            },\n            onerror: (e) => console.error(\"Live error:\", e),\n            onclose: () => console.log(\"Live session closed\"),\n        },\n    });\n    setSession(s);\n\n    // Open mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // *** FIX: Store audio nodes in the ref ***\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1);\n    \n    // Save nodes to ref\n    audioProcessingRef.current = { ctx, src, proc };\n\n    src.connect(proc);\n    proc.connect(ctx.destination);\n    proc.onaudioprocess = (e) => {\n      // Check if session is still active before sending\n      if (s && !s.isClosed) {\n        const inBuf = e.inputBuffer.getChannelData(0);\n        const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n        const pcm16 = floatTo16BitPCM(ds);\n        const mime = \"audio/pcm;rate=16000\";\n        s.sendRealtimeInput({\n          audio: { data: arrayBufferToBase64(pcm16.buffer), mimeType: mime },\n        });\n      }\n    };\n  };\n\n  const stopLive = async () => {\n    // *** FIX: New ordered cleanup logic ***\n    \n    // 1. Stop the audio processor from sending any more data\n    const { proc, src, ctx } = audioProcessingRef.current;\n    if (proc) {\n      proc.disconnect();\n      proc.onaudioprocess = null; // Remove the handler\n    }\n    if (src) {\n      src.disconnect();\n    }\n\n    // 2. Stop the microphone track\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    \n    // 3. NOW it's safe to close the session\n    if (session) {\n      await session.close?.().catch(() => {});\n      setSession(null);\n    }\n    \n    // 4. Close the audio context\n    if (ctx) {\n      await ctx.close().catch(() => {});\n    }\n\n    // 5. Reset all state\n    audioQueue.current = [];\n    isPlaybackActive.current = false;\n    setIsSpeaking(false);\n    audioProcessingRef.current = {};\n  };\n\n  const sendText = async (text) => {\n    if (!session) return;\n    addToHistory(\"AI\", text);\n    session.sendClientContent({ text, turnComplete: true });\n  };\n  \n  // (Render method remains the same)\n  return (\n    <div className=\"app\">\n      {/* ... JSX from previous step ... */}\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}