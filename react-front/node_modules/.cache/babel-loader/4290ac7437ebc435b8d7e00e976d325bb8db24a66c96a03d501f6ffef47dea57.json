{"ast":null,"code":"var _jsxFileName = \"/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\"; // Modality import not strictly needed\n\n// Correct Live model id\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MODEL = \"gemini-2.5-flash-live-preview\";\n\n// Live output is 24 kHz PCM. We'll create a 24k AudioContext for clean playback.\nconst OUTPUT_SAMPLE_RATE = 24000;\nexport default function App() {\n  _s();\n  const avatarRef = useRef(null);\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers: audio conversions ----------\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample to 16k (simple decimator; good enough to get going)\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: 24k PCM Int16 from the model ----------\n  async function playPCM24k(int16le) {\n    // Lazily create an AudioContext at 24k\n    const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: OUTPUT_SAMPLE_RATE\n    });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n    setIsSpeaking(true);\n    src.start();\n    src.onended = () => setIsSpeaking(false);\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    // 1) Ask server for ephemeral token\n    const {\n      token\n    } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(r => r.json());\n\n    // Some servers return {token: \"authTokens/...\"} and some return {token: {name: \"authTokens/...\"}}\n    const ephemeralKey = typeof token === \"string\" ? token : token === null || token === void 0 ? void 0 : token.name;\n\n    // IMPORTANT: Ephemeral tokens require v1alpha on the client\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: {\n        apiVersion: \"v1alpha\"\n      } // <- key line\n    });\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: {\n            prebuiltVoiceConfig: {\n              voiceName: \"Kore\"\n            }\n          }\n        }\n      },\n      callbacks: {\n        onmessage: msg => {\n          var _msg$speechUpdate;\n          // audio can arrive as base64 (most common) OR ArrayBuffer (older builds)\n          const base64Audio = (msg === null || msg === void 0 ? void 0 : (_msg$speechUpdate = msg.speechUpdate) === null || _msg$speechUpdate === void 0 ? void 0 : _msg$speechUpdate.audio) || (msg === null || msg === void 0 ? void 0 : msg.data) || null;\n          if (typeof base64Audio === \"string\") {\n            playPCM24k(base64ToInt16(base64Audio));\n          } else if (base64Audio instanceof ArrayBuffer) {\n            playPCM24k(new Int16Array(base64Audio));\n          }\n\n          // If you want transcripts/text, some builds include msg.text or msg.serverContent\n        },\n        onerror: e => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\")\n      }\n    });\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model (use sendRealtimeInput)\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1); // simple; AudioWorklet is nicer for prod\n    src.connect(proc);\n    proc.connect(ctx.destination); // (or ctx.createGain() to avoid feedback)\n\n    proc.onaudioprocess = e => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      // Optional: downsample to 16k; otherwise use device rate and set MIME accordingly\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n\n      // IMPORTANT: specify sample rate in MIME so Live knows how to interpret it\n      const mime = \"audio/pcm;rate=16000\";\n\n      // ✅ The correct JS Live call for realtime mic streaming:\n      s.sendRealtimeInput({\n        audio: {\n          data: arrayBufferToBase64(pcm16.buffer),\n          mimeType: mime\n        }\n      });\n    };\n  };\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach(t => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        var _session$close;\n        await ((_session$close = session.close) === null || _session$close === void 0 ? void 0 : _session$close.call(session));\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async text => {\n    if (!session) return;\n    // Use the newer method; include turnComplete so the model starts responding\n    session.sendClientContent({\n      text,\n      turnComplete: true\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Talking AI Avatar (Gemini Live)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Lottie, {\n      lottieRef: avatarRef,\n      animationData: talkingAvatar,\n      loop: true,\n      autoplay: false,\n      style: {\n        height: 300\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 203,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginTop: 12\n      },\n      children: !session ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startLive,\n        children: \"Start Live\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 213,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => sendText(\"नमस्ते! आप कैसे हैं?\"),\n          children: \"Send Text Turn\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 216,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: stopLive,\n          children: \"Stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 219,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        opacity: 0.7,\n        marginTop: 8\n      },\n      children: session ? isSpeaking ? \"Model is speaking...\" : \"Live connected. Speak into your mic.\" : \"Click Start Live and give mic permission.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 200,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"K+h1czJ5QEBnJ7+PHKcczj8dIUw=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useMemo","useRef","useState","Lottie","talkingAvatar","GoogleGenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","MODEL","OUTPUT_SAMPLE_RATE","App","_s","avatarRef","session","setSession","audioCtx","setAudioCtx","micStream","setMicStream","isSpeaking","setIsSpeaking","current","play","stop","floatTo16BitPCM","float32","out","Int16Array","length","i","s","Math","max","min","downsampleTo16k","inRate","outRate","ratio","newLen","floor","Float32Array","pos","arrayBufferToBase64","ab","bytes","Uint8Array","bin","String","fromCharCode","btoa","base64ToInt16","b64","from","atob","c","charCodeAt","buffer","playPCM24k","int16le","ctx","window","AudioContext","webkitAudioContext","sampleRate","f32","createBuffer","copyToChannel","src","createBufferSource","connect","destination","start","onended","startLive","token","fetch","then","r","json","ephemeralKey","name","ai","apiKey","httpOptions","apiVersion","live","model","config","responseModalities","speechConfig","languageCode","voiceConfig","prebuiltVoiceConfig","voiceName","callbacks","onmessage","msg","_msg$speechUpdate","base64Audio","speechUpdate","audio","data","ArrayBuffer","onerror","e","console","error","onclose","log","stream","navigator","mediaDevices","getUserMedia","createMediaStreamSource","proc","createScriptProcessor","onaudioprocess","inBuf","inputBuffer","getChannelData","ds","pcm16","mime","sendRealtimeInput","mimeType","stopLive","getTracks","forEach","t","_session$close","close","call","sendText","text","sendClientContent","turnComplete","className","children","fileName","_jsxFileName","lineNumber","columnNumber","lottieRef","animationData","loop","autoplay","style","height","display","gap","marginTop","onClick","opacity","_c","$RefreshReg$"],"sources":["/private/var/www/html/dev-app/live-stream-talk/react-front/src/App.js"],"sourcesContent":["// src/App.js\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport Lottie from \"lottie-react\";\nimport talkingAvatar from \"./talking-avatar.json\";\nimport { GoogleGenAI } from \"@google/genai\"; // Modality import not strictly needed\n\n// Correct Live model id\nconst MODEL = \"gemini-2.5-flash-live-preview\";\n\n// Live output is 24 kHz PCM. We'll create a 24k AudioContext for clean playback.\nconst OUTPUT_SAMPLE_RATE = 24000;\n\nexport default function App() {\n  const avatarRef = useRef(null);\n\n  // Live session state\n  const [session, setSession] = useState(null);\n  const [audioCtx, setAudioCtx] = useState(null);\n  const [micStream, setMicStream] = useState(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Start/stop avatar based on speaking flag\n  useEffect(() => {\n    if (!avatarRef.current) return;\n    if (isSpeaking) avatarRef.current.play();\n    else avatarRef.current.stop();\n  }, [isSpeaking]);\n\n  // ---------- helpers: audio conversions ----------\n\n  // Float32 → Int16 little-endian\n  function floatTo16BitPCM(float32) {\n    const out = new Int16Array(float32.length);\n    for (let i = 0; i < float32.length; i++) {\n      const s = Math.max(-1, Math.min(1, float32[i]));\n      out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;\n    }\n    return out;\n  }\n\n  // Downsample to 16k (simple decimator; good enough to get going)\n  function downsampleTo16k(float32, inRate) {\n    const outRate = 16000;\n    if (inRate === outRate) return float32;\n    const ratio = inRate / outRate;\n    const newLen = Math.floor(float32.length / ratio);\n    const out = new Float32Array(newLen);\n    let pos = 0;\n    for (let i = 0; i < newLen; i++, pos += ratio) {\n      out[i] = float32[Math.floor(pos)];\n    }\n    return out;\n  }\n\n  // ArrayBuffer → base64\n  function arrayBufferToBase64(ab) {\n    const bytes = new Uint8Array(ab);\n    let bin = \"\";\n    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n    return btoa(bin);\n  }\n\n  // base64 → Int16Array\n  function base64ToInt16(b64) {\n    const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n    return new Int16Array(bytes.buffer);\n  }\n\n  // ---------- playback: 24k PCM Int16 from the model ----------\n  async function playPCM24k(int16le) {\n    // Lazily create an AudioContext at 24k\n    const ctx =\n      audioCtx ||\n      new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: OUTPUT_SAMPLE_RATE,\n      });\n    if (!audioCtx) setAudioCtx(ctx);\n\n    // Convert Int16 → Float32 buffer for WebAudio\n    const f32 = new Float32Array(int16le.length);\n    for (let i = 0; i < int16le.length; i++) {\n      f32[i] = int16le[i] / 0x8000;\n    }\n\n    // Create an AudioBuffer and schedule playback\n    const buffer = ctx.createBuffer(1, f32.length, OUTPUT_SAMPLE_RATE);\n    buffer.copyToChannel(f32, 0, 0);\n    const src = ctx.createBufferSource();\n    src.buffer = buffer;\n    src.connect(ctx.destination);\n\n    setIsSpeaking(true);\n    src.start();\n    src.onended = () => setIsSpeaking(false);\n  }\n\n  // ---------- Live session start / stop ----------\n\n  const startLive = async () => {\n    // 1) Ask server for ephemeral token\n    const { token } = await fetch(\"http://localhost:8787/api/ephemeral-token\").then(\n      (r) => r.json()\n    );\n\n    // Some servers return {token: \"authTokens/...\"} and some return {token: {name: \"authTokens/...\"}}\n    const ephemeralKey = typeof token === \"string\" ? token : token?.name;\n\n    // IMPORTANT: Ephemeral tokens require v1alpha on the client\n    const ai = new GoogleGenAI({\n      apiKey: ephemeralKey,\n      httpOptions: { apiVersion: \"v1alpha\" }, // <- key line\n    });\n\n    const s = await ai.live.connect({\n      model: MODEL,\n      config: {\n        responseModalities: [\"AUDIO\"],\n        speechConfig: {\n          languageCode: \"hi-IN\",\n          voiceConfig: { prebuiltVoiceConfig: { voiceName: \"Kore\" } },\n        },\n      },\n      callbacks: {\n        onmessage: (msg) => {\n          // audio can arrive as base64 (most common) OR ArrayBuffer (older builds)\n          const base64Audio = msg?.speechUpdate?.audio || msg?.data || null;\n\n          if (typeof base64Audio === \"string\") {\n            playPCM24k(base64ToInt16(base64Audio));\n          } else if (base64Audio instanceof ArrayBuffer) {\n            playPCM24k(new Int16Array(base64Audio));\n          }\n\n          // If you want transcripts/text, some builds include msg.text or msg.serverContent\n        },\n        onerror: (e) => console.error(\"Live error:\", e),\n        onclose: () => console.log(\"Live session closed\"),\n      },\n    });\n    setSession(s);\n\n    // 3) Open the mic\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    setMicStream(stream);\n\n    // 4) Capture mic frames and send to the model (use sendRealtimeInput)\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n    const src = ctx.createMediaStreamSource(stream);\n    const proc = ctx.createScriptProcessor(4096, 1, 1); // simple; AudioWorklet is nicer for prod\n    src.connect(proc);\n    proc.connect(ctx.destination); // (or ctx.createGain() to avoid feedback)\n\n    proc.onaudioprocess = (e) => {\n      const inBuf = e.inputBuffer.getChannelData(0);\n      // Optional: downsample to 16k; otherwise use device rate and set MIME accordingly\n      const ds = downsampleTo16k(inBuf, ctx.sampleRate);\n      const pcm16 = floatTo16BitPCM(ds);\n\n      // IMPORTANT: specify sample rate in MIME so Live knows how to interpret it\n      const mime = \"audio/pcm;rate=16000\";\n\n      // ✅ The correct JS Live call for realtime mic streaming:\n      s.sendRealtimeInput({\n        audio: { data: arrayBufferToBase64(pcm16.buffer), mimeType: mime },\n      });\n    };\n  };\n\n  const stopLive = async () => {\n    if (micStream) {\n      micStream.getTracks().forEach((t) => t.stop());\n      setMicStream(null);\n    }\n    if (session) {\n      try {\n        await session.close?.();\n      } catch {}\n      setSession(null);\n    }\n    if (audioCtx) {\n      try {\n        await audioCtx.close();\n      } catch {}\n      setAudioCtx(null);\n    }\n    setIsSpeaking(false);\n  };\n\n  // Optional: send a text turn to the model (while mic streaming)\n  const sendText = async (text) => {\n    if (!session) return;\n    // Use the newer method; include turnComplete so the model starts responding\n    session.sendClientContent({\n      text,\n      turnComplete: true,\n    });\n  };\n\n  return (\n    <div className=\"app\">\n      <h2>Talking AI Avatar (Gemini Live)</h2>\n\n      <Lottie\n        lottieRef={avatarRef}\n        animationData={talkingAvatar}\n        loop\n        autoplay={false}\n        style={{ height: 300 }}\n      />\n\n      <div style={{ display: \"flex\", gap: 8, marginTop: 12 }}>\n        {!session ? (\n          <button onClick={startLive}>Start Live</button>\n        ) : (\n          <>\n            <button onClick={() => sendText(\"नमस्ते! आप कैसे हैं?\")}>\n              Send Text Turn\n            </button>\n            <button onClick={stopLive}>Stop</button>\n          </>\n        )}\n      </div>\n\n      <p style={{ opacity: 0.7, marginTop: 8 }}>\n        {session\n          ? isSpeaking\n            ? \"Model is speaking...\"\n            : \"Live connected. Speak into your mic.\"\n          : \"Click Start Live and give mic permission.\"}\n      </p>\n    </div>\n  );\n}\n"],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACnE,OAAOC,MAAM,MAAM,cAAc;AACjC,OAAOC,aAAa,MAAM,uBAAuB;AACjD,SAASC,WAAW,QAAQ,eAAe,CAAC,CAAC;;AAE7C;AAAA,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AACA,MAAMC,KAAK,GAAG,+BAA+B;;AAE7C;AACA,MAAMC,kBAAkB,GAAG,KAAK;AAEhC,eAAe,SAASC,GAAGA,CAAA,EAAG;EAAAC,EAAA;EAC5B,MAAMC,SAAS,GAAGb,MAAM,CAAC,IAAI,CAAC;;EAE9B;EACA,MAAM,CAACc,OAAO,EAAEC,UAAU,CAAC,GAAGd,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM,CAACe,QAAQ,EAAEC,WAAW,CAAC,GAAGhB,QAAQ,CAAC,IAAI,CAAC;EAC9C,MAAM,CAACiB,SAAS,EAAEC,YAAY,CAAC,GAAGlB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACmB,UAAU,EAAEC,aAAa,CAAC,GAAGpB,QAAQ,CAAC,KAAK,CAAC;;EAEnD;EACAH,SAAS,CAAC,MAAM;IACd,IAAI,CAACe,SAAS,CAACS,OAAO,EAAE;IACxB,IAAIF,UAAU,EAAEP,SAAS,CAACS,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC,KACpCV,SAAS,CAACS,OAAO,CAACE,IAAI,CAAC,CAAC;EAC/B,CAAC,EAAE,CAACJ,UAAU,CAAC,CAAC;;EAEhB;;EAEA;EACA,SAASK,eAAeA,CAACC,OAAO,EAAE;IAChC,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACF,OAAO,CAACG,MAAM,CAAC;IAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,OAAO,CAACG,MAAM,EAAEC,CAAC,EAAE,EAAE;MACvC,MAAMC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAER,OAAO,CAACI,CAAC,CAAC,CAAC,CAAC;MAC/CH,GAAG,CAACG,CAAC,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,MAAM,GAAGA,CAAC,GAAG,MAAM;IAC1C;IACA,OAAOJ,GAAG;EACZ;;EAEA;EACA,SAASQ,eAAeA,CAACT,OAAO,EAAEU,MAAM,EAAE;IACxC,MAAMC,OAAO,GAAG,KAAK;IACrB,IAAID,MAAM,KAAKC,OAAO,EAAE,OAAOX,OAAO;IACtC,MAAMY,KAAK,GAAGF,MAAM,GAAGC,OAAO;IAC9B,MAAME,MAAM,GAAGP,IAAI,CAACQ,KAAK,CAACd,OAAO,CAACG,MAAM,GAAGS,KAAK,CAAC;IACjD,MAAMX,GAAG,GAAG,IAAIc,YAAY,CAACF,MAAM,CAAC;IACpC,IAAIG,GAAG,GAAG,CAAC;IACX,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,MAAM,EAAET,CAAC,EAAE,EAAEY,GAAG,IAAIJ,KAAK,EAAE;MAC7CX,GAAG,CAACG,CAAC,CAAC,GAAGJ,OAAO,CAACM,IAAI,CAACQ,KAAK,CAACE,GAAG,CAAC,CAAC;IACnC;IACA,OAAOf,GAAG;EACZ;;EAEA;EACA,SAASgB,mBAAmBA,CAACC,EAAE,EAAE;IAC/B,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACF,EAAE,CAAC;IAChC,IAAIG,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,KAAK,CAAChB,MAAM,EAAEC,CAAC,EAAE,EAAEiB,GAAG,IAAIC,MAAM,CAACC,YAAY,CAACJ,KAAK,CAACf,CAAC,CAAC,CAAC;IAC3E,OAAOoB,IAAI,CAACH,GAAG,CAAC;EAClB;;EAEA;EACA,SAASI,aAAaA,CAACC,GAAG,EAAE;IAC1B,MAAMP,KAAK,GAAGC,UAAU,CAACO,IAAI,CAACC,IAAI,CAACF,GAAG,CAAC,EAAGG,CAAC,IAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAChE,OAAO,IAAI5B,UAAU,CAACiB,KAAK,CAACY,MAAM,CAAC;EACrC;;EAEA;EACA,eAAeC,UAAUA,CAACC,OAAO,EAAE;IACjC;IACA,MAAMC,GAAG,GACP5C,QAAQ,IACR,KAAK6C,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE;MACrDC,UAAU,EAAEtD;IACd,CAAC,CAAC;IACJ,IAAI,CAACM,QAAQ,EAAEC,WAAW,CAAC2C,GAAG,CAAC;;IAE/B;IACA,MAAMK,GAAG,GAAG,IAAIxB,YAAY,CAACkB,OAAO,CAAC9B,MAAM,CAAC;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,OAAO,CAAC9B,MAAM,EAAEC,CAAC,EAAE,EAAE;MACvCmC,GAAG,CAACnC,CAAC,CAAC,GAAG6B,OAAO,CAAC7B,CAAC,CAAC,GAAG,MAAM;IAC9B;;IAEA;IACA,MAAM2B,MAAM,GAAGG,GAAG,CAACM,YAAY,CAAC,CAAC,EAAED,GAAG,CAACpC,MAAM,EAAEnB,kBAAkB,CAAC;IAClE+C,MAAM,CAACU,aAAa,CAACF,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,MAAMG,GAAG,GAAGR,GAAG,CAACS,kBAAkB,CAAC,CAAC;IACpCD,GAAG,CAACX,MAAM,GAAGA,MAAM;IACnBW,GAAG,CAACE,OAAO,CAACV,GAAG,CAACW,WAAW,CAAC;IAE5BlD,aAAa,CAAC,IAAI,CAAC;IACnB+C,GAAG,CAACI,KAAK,CAAC,CAAC;IACXJ,GAAG,CAACK,OAAO,GAAG,MAAMpD,aAAa,CAAC,KAAK,CAAC;EAC1C;;EAEA;;EAEA,MAAMqD,SAAS,GAAG,MAAAA,CAAA,KAAY;IAC5B;IACA,MAAM;MAAEC;IAAM,CAAC,GAAG,MAAMC,KAAK,CAAC,2CAA2C,CAAC,CAACC,IAAI,CAC5EC,CAAC,IAAKA,CAAC,CAACC,IAAI,CAAC,CAChB,CAAC;;IAED;IACA,MAAMC,YAAY,GAAG,OAAOL,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAGA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEM,IAAI;;IAEpE;IACA,MAAMC,EAAE,GAAG,IAAI9E,WAAW,CAAC;MACzB+E,MAAM,EAAEH,YAAY;MACpBI,WAAW,EAAE;QAAEC,UAAU,EAAE;MAAU,CAAC,CAAE;IAC1C,CAAC,CAAC;IAEF,MAAMtD,CAAC,GAAG,MAAMmD,EAAE,CAACI,IAAI,CAAChB,OAAO,CAAC;MAC9BiB,KAAK,EAAE9E,KAAK;MACZ+E,MAAM,EAAE;QACNC,kBAAkB,EAAE,CAAC,OAAO,CAAC;QAC7BC,YAAY,EAAE;UACZC,YAAY,EAAE,OAAO;UACrBC,WAAW,EAAE;YAAEC,mBAAmB,EAAE;cAAEC,SAAS,EAAE;YAAO;UAAE;QAC5D;MACF,CAAC;MACDC,SAAS,EAAE;QACTC,SAAS,EAAGC,GAAG,IAAK;UAAA,IAAAC,iBAAA;UAClB;UACA,MAAMC,WAAW,GAAG,CAAAF,GAAG,aAAHA,GAAG,wBAAAC,iBAAA,GAAHD,GAAG,CAAEG,YAAY,cAAAF,iBAAA,uBAAjBA,iBAAA,CAAmBG,KAAK,MAAIJ,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEK,IAAI,KAAI,IAAI;UAEjE,IAAI,OAAOH,WAAW,KAAK,QAAQ,EAAE;YACnCzC,UAAU,CAACP,aAAa,CAACgD,WAAW,CAAC,CAAC;UACxC,CAAC,MAAM,IAAIA,WAAW,YAAYI,WAAW,EAAE;YAC7C7C,UAAU,CAAC,IAAI9B,UAAU,CAACuE,WAAW,CAAC,CAAC;UACzC;;UAEA;QACF,CAAC;QACDK,OAAO,EAAGC,CAAC,IAAKC,OAAO,CAACC,KAAK,CAAC,aAAa,EAAEF,CAAC,CAAC;QAC/CG,OAAO,EAAEA,CAAA,KAAMF,OAAO,CAACG,GAAG,CAAC,qBAAqB;MAClD;IACF,CAAC,CAAC;IACF9F,UAAU,CAACgB,CAAC,CAAC;;IAEb;IACA,MAAM+E,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MAAEZ,KAAK,EAAE;IAAK,CAAC,CAAC;IACzElF,YAAY,CAAC2F,MAAM,CAAC;;IAEpB;IACA,MAAMlD,GAAG,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;IACpE,MAAMK,GAAG,GAAGR,GAAG,CAACsD,uBAAuB,CAACJ,MAAM,CAAC;IAC/C,MAAMK,IAAI,GAAGvD,GAAG,CAACwD,qBAAqB,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACpDhD,GAAG,CAACE,OAAO,CAAC6C,IAAI,CAAC;IACjBA,IAAI,CAAC7C,OAAO,CAACV,GAAG,CAACW,WAAW,CAAC,CAAC,CAAC;;IAE/B4C,IAAI,CAACE,cAAc,GAAIZ,CAAC,IAAK;MAC3B,MAAMa,KAAK,GAAGb,CAAC,CAACc,WAAW,CAACC,cAAc,CAAC,CAAC,CAAC;MAC7C;MACA,MAAMC,EAAE,GAAGtF,eAAe,CAACmF,KAAK,EAAE1D,GAAG,CAACI,UAAU,CAAC;MACjD,MAAM0D,KAAK,GAAGjG,eAAe,CAACgG,EAAE,CAAC;;MAEjC;MACA,MAAME,IAAI,GAAG,sBAAsB;;MAEnC;MACA5F,CAAC,CAAC6F,iBAAiB,CAAC;QAClBvB,KAAK,EAAE;UAAEC,IAAI,EAAE3D,mBAAmB,CAAC+E,KAAK,CAACjE,MAAM,CAAC;UAAEoE,QAAQ,EAAEF;QAAK;MACnE,CAAC,CAAC;IACJ,CAAC;EACH,CAAC;EAED,MAAMG,QAAQ,GAAG,MAAAA,CAAA,KAAY;IAC3B,IAAI5G,SAAS,EAAE;MACbA,SAAS,CAAC6G,SAAS,CAAC,CAAC,CAACC,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAACzG,IAAI,CAAC,CAAC,CAAC;MAC9CL,YAAY,CAAC,IAAI,CAAC;IACpB;IACA,IAAIL,OAAO,EAAE;MACX,IAAI;QAAA,IAAAoH,cAAA;QACF,QAAAA,cAAA,GAAMpH,OAAO,CAACqH,KAAK,cAAAD,cAAA,uBAAbA,cAAA,CAAAE,IAAA,CAAAtH,OAAgB,CAAC;MACzB,CAAC,CAAC,MAAM,CAAC;MACTC,UAAU,CAAC,IAAI,CAAC;IAClB;IACA,IAAIC,QAAQ,EAAE;MACZ,IAAI;QACF,MAAMA,QAAQ,CAACmH,KAAK,CAAC,CAAC;MACxB,CAAC,CAAC,MAAM,CAAC;MACTlH,WAAW,CAAC,IAAI,CAAC;IACnB;IACAI,aAAa,CAAC,KAAK,CAAC;EACtB,CAAC;;EAED;EACA,MAAMgH,QAAQ,GAAG,MAAOC,IAAI,IAAK;IAC/B,IAAI,CAACxH,OAAO,EAAE;IACd;IACAA,OAAO,CAACyH,iBAAiB,CAAC;MACxBD,IAAI;MACJE,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ,CAAC;EAED,oBACElI,OAAA;IAAKmI,SAAS,EAAC,KAAK;IAAAC,QAAA,gBAClBpI,OAAA;MAAAoI,QAAA,EAAI;IAA+B;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eAExCxI,OAAA,CAACJ,MAAM;MACL6I,SAAS,EAAElI,SAAU;MACrBmI,aAAa,EAAE7I,aAAc;MAC7B8I,IAAI;MACJC,QAAQ,EAAE,KAAM;MAChBC,KAAK,EAAE;QAAEC,MAAM,EAAE;MAAI;IAAE;MAAAT,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACxB,CAAC,eAEFxI,OAAA;MAAK6I,KAAK,EAAE;QAAEE,OAAO,EAAE,MAAM;QAAEC,GAAG,EAAE,CAAC;QAAEC,SAAS,EAAE;MAAG,CAAE;MAAAb,QAAA,EACpD,CAAC5H,OAAO,gBACPR,OAAA;QAAQkJ,OAAO,EAAE9E,SAAU;QAAAgE,QAAA,EAAC;MAAU;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,gBAE/CxI,OAAA,CAAAE,SAAA;QAAAkI,QAAA,gBACEpI,OAAA;UAAQkJ,OAAO,EAAEA,CAAA,KAAMnB,QAAQ,CAAC,sBAAsB,CAAE;UAAAK,QAAA,EAAC;QAEzD;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC,eACTxI,OAAA;UAAQkJ,OAAO,EAAE1B,QAAS;UAAAY,QAAA,EAAC;QAAI;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC;MAAA,eACxC;IACH;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC,eAENxI,OAAA;MAAG6I,KAAK,EAAE;QAAEM,OAAO,EAAE,GAAG;QAAEF,SAAS,EAAE;MAAE,CAAE;MAAAb,QAAA,EACtC5H,OAAO,GACJM,UAAU,GACR,sBAAsB,GACtB,sCAAsC,GACxC;IAA2C;MAAAuH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC9C,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACD,CAAC;AAEV;AAAClI,EAAA,CA5NuBD,GAAG;AAAA+I,EAAA,GAAH/I,GAAG;AAAA,IAAA+I,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}